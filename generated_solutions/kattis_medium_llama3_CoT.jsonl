{"task_id": "Left and Right", "final_solution": "def main():\n    n = int(input())\n    directions = input()\n\n    # Initialize the result list with numbers from 1 to n\n    result = list(range(1, n + 1))\n\n    # Initialize the current position to 0\n    pos = 0\n\n    # Iterate over the directions\n    for direction in directions:\n        # If the direction is 'L', decrement the position\n        if direction == 'L':\n            pos = max(0, pos - 1)\n        # If the direction is 'R', increment the position\n        else:\n            pos = min(n - 1, pos + 1)\n\n        # Move the current element to the correct position in the result list\n        result.insert(pos, result.pop(0))\n\n    # Print the result list\n    for i in result:\n        print(i)\n\nif __name__ == '__main__':\n    main()\n", "initial_solution": "def main():\n    n = int(input())\n    directions = input()\n\n    # Initialize the result list with 1\n    result = [1]\n\n    # Initialize the current position to 1\n    pos = 1\n\n    # Iterate over the directions\n    for direction in directions:\n        # If the direction is 'L', decrement the position\n        if direction == 'L':\n            pos -= 1\n        # If the direction is 'R', increment the position\n        else:\n            pos += 1\n\n        # Insert the current position at the correct index in the result list\n        result.insert(pos - 1, pos + 1)\n\n    # Print the result list\n    for i in result:\n        print(i)\n\nif __name__ == '__main__':\n    main()\n"}
{"task_id": "Combination Lock", "final_solution": "def main():\n    while True:\n        nums = list(map(int, input().split()))\n        if nums == [0, 0, 0, 0]:\n            break\n        init_pos, num1, num2, num3 = nums\n        total_turns = 0\n        \n        # Calculate the clockwise turns for the first number\n        total_turns += min((num1 - init_pos) % 40, (init_pos - num1 + 40) % 40) * 9\n        \n        # Calculate the counter-clockwise turns for the second number\n        total_turns += min((num2 - num1) % 40, (num1 - num2 + 40) % 40) * 9\n        \n        # Calculate the clockwise turns for the third number\n        total_turns += min((num3 - num2) % 40, (num2 - num3 + 40) % 40) * 9\n        \n        print(total_turns)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    while True:\n        nums = list(map(int, input().split()))\n        if nums == [0, 0, 0, 0]:\n            break\n        init_pos, num1, num2, num3 = nums\n        total_turns = 0\n        \n        # Calculate the clockwise turns for the first number\n        total_turns += (2 * 40 - init_pos + num1) % 40\n        \n        # Calculate the counter-clockwise turns for the second number\n        total_turns += (num1 - num2) % 40\n        \n        # Calculate the clockwise turns for the third number\n        total_turns += (num2 - num3) % 40\n        \n        # Convert the total turns to degrees\n        total_degrees = total_turns * 9\n        \n        print(total_degrees)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "The Uxuhul Voting System", "final_solution": "def main():\n    n = int(input())\n    for _ in range(n):\n        m = int(input())\n        prefs = []\n        for _ in range(m):\n            prefs.append(list(map(int, input().split())))\n        \n        # Initialize the stones to all black (no)\n        stones = [0, 0, 0]\n        \n        # Simulate the voting process\n        for pref in prefs:\n            # Find the issue that will change the outcome the most\n            max_diff = 0\n            max_issue = -1\n            for i in range(3):\n                if pref[2**i - 1] < pref[7 - 2**i]:\n                    diff = pref[2**i - 1] - pref[7 - 2**i]\n                    if diff > max_diff:\n                        max_diff = diff\n                        max_issue = i\n                else:\n                    diff = pref[7 - 2**i] - pref[2**i - 1]\n                    if diff > max_diff:\n                        max_diff = diff\n                        max_issue = i\n            \n            # Flip the stone that will change the outcome the most\n            stones[max_issue] = 1 - stones[max_issue]\n        \n        # Print the outcome of the votes\n        outcome = ''.join(['Y' if stone else 'N' for stone in stones])\n        print(outcome)\n\nif __name__ == '__main__':\n    main()\n", "initial_solution": "def main():\n    n = int(input())\n    for _ in range(n):\n        m = int(input())\n        prefs = []\n        for _ in range(m):\n            prefs.append(list(map(int, input().split())))\n        \n        # Initialize the stones to all black (no)\n        stones = [0, 0, 0]\n        \n        # Simulate the voting process\n        for pref in prefs:\n            # Find the issue that will change the outcome the most\n            max_diff = 0\n            max_issue = -1\n            for i in range(3):\n                if pref[2**i - 1] < pref[7 - 2**i]:\n                    diff = pref[2**i - 1] - pref[7 - 2**i]\n                    if diff > max_diff:\n                        max_diff = diff\n                        max_issue = i\n            \n            # Flip the stone that will change the outcome the most\n            stones[max_issue] = 1 - stones[max_issue]\n        \n        # Print the outcome of the votes\n        outcome = ''.join(['Y' if stone else 'N' for stone in stones])\n        print(outcome)\n\nif __name__ == '__main__':\n    main()\n"}
{"task_id": "Crop Triangles (Easy)", "final_solution": "def main():\n    T = int(input())\n    for case in range(T):\n        n, A, B, C, D, x0, y0, M = map(int, input().split())\n        points = set()\n        x, y = x0, y0\n        for _ in range(n):\n            points.add((x, y))\n            x, y = (A * x + B) % M, (C * y + D) % M\n        triangles = 0\n        for p1 in points:\n            for p2 in points:\n                if p1 == p2:\n                    continue\n                for p3 in points:\n                    if p1 == p3 or p2 == p3:\n                        continue\n                    x1, y1 = p1\n                    x2, y2 = p2\n                    x3, y3 = p3\n                    cx, cy = ((x1 + x2 + x3) // 3, (y1 + y2 + y3) // 3)\n                    if cx * 3 == x1 + x2 + x3 and cy * 3 == y1 + y2 + y3 and (cx, cy) in points:\n                        triangles += 1\n        print(f\"Case #{case + 1}: {triangles // 6}\")\nif __name__ == '__main__':\n    main()\n", "initial_solution": "def main():\n    T = int(input())\n    for case in range(T):\n        n, A, B, C, D, x0, y0, M = map(int, input().split())\n        points = set()\n        x, y = x0, y0\n        for _ in range(n):\n            points.add((x, y))\n            x, y = (A * x + B) % M, (C * y + D) % M\n        triangles = 0\n        for p1 in points:\n            for p2 in points:\n                if p1 == p2:\n                    continue\n                for p3 in points:\n                    if p1 == p3 or p2 == p3:\n                        continue\n                    x1, y1 = p1\n                    x2, y2 = p2\n                    x3, y3 = p3\n                    cx, cy = ((x1 + x2 + x3) // 3, (y1 + y2 + y3) // 3)\n                    if (cx, cy) in points:\n                        triangles += 1\n        print(f\"Case #{case + 1}: {triangles}\")\n\nif __name__ == '__main__':\n    main()\n"}
{"task_id": "Relatives", "final_solution": "def main():\n    def euler_totient(n):\n        result = n\n        p = 2\n        while p * p <= n:\n            if n % p == 0:\n                while n % p == 0:\n                    n //= p\n                result -= result // p\n            p += 1\n        if n > 1:\n            result -= result // n\n        return result\n\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        print(euler_totient(n))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    def euler_totient(n):\n        result = n\n        p = 2\n        while p * p <= n:\n            if n % p == 0:\n                while n % p == 0:\n                    n //= p\n                result -= result // p\n            p += 1\n        if n > 1:\n            result -= result // n\n        return result\n\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        print(euler_totient(n))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Bank Queue", "final_solution": "import unittest\nfrom unittest.mock import patch\nfrom io import StringIO\n\ndef main():\n    N, T = map(int, input().split())\n    people = []\n    for _ in range(N):\n        c, t = map(int, input().split())\n        people.append((c, t))\n    \n    people.sort(key=lambda x: x[1])\n    dp = [0] * (T + 1)\n    for c, t in people:\n        for i in range(t, -1, -1):\n            dp[i] = max(dp[i], dp[i - 1] + c)\n    \n    print(max(dp))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    N, T = map(int, input().split())\n    people = []\n    for _ in range(N):\n        c, t = map(int, input().split())\n        people.append((c, t))\n    \n    people.sort(key=lambda x: x[1])\n    dp = [0] * (T + 1)\n    for c, t in people:\n        for i in range(T, t - 1, -1):\n            dp[i] = max(dp[i], dp[i - 1] + c)\n    \n    print(dp[T])\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Guessing Game", "final_solution": "def main():\n    while True:\n        lines = []\n        while True:\n            line = input()\n            if line == '0':\n                break\n            lines.append(line)\n        if not lines:\n            break\n        guesses = []\n        for i in range(0, len(lines), 2):\n            guess = int(lines[i])\n            response = lines[i + 1]\n            guesses.append((guess, response))\n        low, high = 1, 10\n        for guess, response in guesses:\n            if response == 'too high':\n                high = min(high, guess - 1)\n            elif response == 'too low':\n                low = max(low, guess + 1)\n            else:\n                if guess < low or guess > high:\n                    print(\"Stan is dishonest\")\n                    break\n                else:\n                    print(\"Stan may be honest\")\n                    break\n        else:\n            if len(guesses) == 0:\n                continue\n            last_guess, last_response = guesses[-1]\n            if last_response != 'right on':\n                print(\"Stan is dishonest\")\n            else:\n                print(\"Stan may be honest\")\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    while True:\n        lines = []\n        while True:\n            line = input()\n            if line == '0':\n                break\n            lines.append(line)\n        if not lines:\n            break\n        guesses = []\n        for i in range(0, len(lines), 2):\n            guess = int(lines[i])\n            response = lines[i + 1]\n            guesses.append((guess, response))\n        low, high = 1, 10\n        for guess, response in guesses:\n            if response == 'too high':\n                high = min(high, guess - 1)\n            elif response == 'too low':\n                low = max(low, guess + 1)\n            else:\n                if guess < low or guess > high:\n                    print(\"Stan is dishonest\")\n                    break\n                else:\n                    print(\"Stan may be honest\")\n                    break\n        else:\n            print(\"Stan may be honest\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Phone List", "final_solution": "def main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        phone_numbers = [input() for _ in range(n)]\n        phone_numbers.sort()\n        consistent = True\n        for i in range(n - 1):\n            if phone_numbers[i + 1].startswith(phone_numbers[i]):\n                consistent = False\n                break\n        print(\"YES\" if consistent else \"NO\")\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        phone_numbers = [input() for _ in range(n)]\n        phone_numbers.sort()\n        consistent = True\n        for i in range(n - 1):\n            if phone_numbers[i + 1].startswith(phone_numbers[i]):\n                consistent = False\n                break\n        print(\"YES\" if consistent else \"NO\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Collapse", "final_solution": "def main():\n    N = int(input())\n    islands = []\n    for _ in range(N):\n        T, K = map(int, input().split())\n        supplies = {}\n        for _ in range(K):\n            S, V = map(int, input().split())\n            supplies[S] = V\n        islands.append((T, supplies))\n\n    dead_islands = {1}\n    while dead_islands:\n        new_dead_islands = set()\n        for i, (T, supplies) in enumerate(islands):\n            if i + 1 in dead_islands:\n                continue\n            total_supply = sum(supplies.get(j, 0) for j in range(1, N + 1) if j not in dead_islands)\n            if total_supply < T:\n                new_dead_islands.add(i + 1)\n        dead_islands.update(new_dead_islands)\n        if not new_dead_islands:\n            break\n\n    print(N - len(dead_islands))\n\nif __name__ == '__main__':\n    main()\n", "initial_solution": "def main():\n    N = int(input())\n    islands = []\n    for _ in range(N):\n        T, K = map(int, input().split())\n        supplies = {}\n        for _ in range(K):\n            S, V = map(int, input().split())\n            supplies[S] = V\n        islands.append((T, supplies))\n\n    dead_islands = {1}\n    while dead_islands:\n        new_dead_islands = set()\n        for i, (T, supplies) in enumerate(islands):\n            if i + 1 in dead_islands:\n                continue\n            total_supply = sum(supplies.get(j, 0) for j in range(1, N + 1) if j not in dead_islands)\n            if total_supply < T:\n                new_dead_islands.add(i + 1)\n        dead_islands.update(new_dead_islands)\n        if not new_dead_islands:\n            break\n\n    print(N - len(dead_islands))\n\nif __name__ == '__main__':\n    main()\n"}
{"task_id": "Button Bashing", "final_solution": "def main():\n    T = int(input())\n    for _ in range(T):\n        n, t = map(int, input().split())\n        buttons = list(map(int, input().split()))\n        \n        dp = [float('inf')] * (3601)\n        dp[0] = 0\n        \n        for i in range(3601):\n            for button in buttons:\n                if 0 <= i + button <= 3600:\n                    dp[i + button] = min(dp[i + button], dp[i] + 1)\n        \n        min_presses = float('inf')\n        min_extra = float('inf')\n        for i in range(t, -1, -1):\n            if dp[i] != float('inf'):\n                min_presses = dp[i]\n                min_extra = max(0, i - t)\n                break\n        \n        print(min_presses, min_extra)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    T = int(input())\n    for _ in range(T):\n        n, t = map(int, input().split())\n        buttons = list(map(int, input().split()))\n        \n        dp = [float('inf')] * (t + 1)\n        dp[0] = 0\n        \n        for i in range(t + 1):\n            for button in buttons:\n                if 0 <= i + button <= t:\n                    dp[i + button] = min(dp[i + button], dp[i] + 1)\n        \n        min_presses = float('inf')\n        min_extra = float('inf')\n        for i in range(t, -1, -1):\n            if dp[i] != float('inf'):\n                min_presses = dp[i]\n                min_extra = i - t\n                break\n        \n        print(min_presses, min_extra)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Biased Standings", "final_solution": "import sys\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        input()  # Consume the blank line\n        N = int(input())\n        prefs = {}\n        for _ in range(N):\n            team, pref = input().split()\n            pref = int(pref)\n            prefs[team] = pref\n        teams = sorted(prefs, key=prefs.get)\n        badness = 0\n        for i, team in enumerate(teams):\n            badness += abs(prefs[team] - (i + 1))\n        print(badness)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    T = int(input())\n\n    for _ in range(T):\n        N = int(input())\n        prefs = {}\n        for _ in range(N):\n            team, pref = input().split()\n            pref = int(pref)\n            prefs[team] = pref\n\n        teams = sorted(prefs, key=prefs.get)\n        badness = 0\n        for i, team in enumerate(teams):\n            badness += abs(prefs[team] - (i + 1))\n\n        print(badness)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Fridge", "final_solution": "def main():\n    # Take user input as a string of digits\n    digits = input()\n\n    # Convert the string of digits to a set to remove duplicates\n    digits = set(digits)\n\n    # Initialize a variable to store the smallest positive number that cannot be made\n    smallest = 1\n\n    # Loop until we find a number that cannot be made\n    while True:\n        # Convert the number to a set of digits\n        num_digits = set(str(smallest))\n\n        # Check if all digits in the number can be found in the available digits\n        if all(digit in digits for digit in num_digits):\n            # If yes, increment the number and continue\n            smallest += 1\n        else:\n            # If not, break the loop and print the smallest number that cannot be made\n            print(smallest)\n            break\n\nif __name__ == '__main__':\n    main()\n", "initial_solution": "def main():\n    # Take user input as a string of digits\n    digits = input()\n\n    # Convert the string of digits to a set to remove duplicates\n    digits = set(digits)\n\n    # Initialize a variable to store the smallest positive number that cannot be made\n    smallest = 1\n\n    # Loop until we find a number that cannot be made\n    while True:\n        # Convert the number to a set of digits\n        num_digits = set(str(smallest))\n\n        # Check if all digits in the number can be found in the available digits\n        if num_digits.issubset(digits):\n            # If yes, increment the number and continue\n            smallest += 1\n        else:\n            # If not, break the loop and print the smallest number that cannot be made\n            print(smallest)\n            break\n\nif __name__ == '__main__':\n    main()\n"}
{"task_id": "Dividing Sequence", "final_solution": "def main():\n    N = int(input())\n\n    # Initialize a list to store the longest sequence length for each number\n    longest_sequence = [1] * (N + 1)\n\n    # Initialize a list to store the previous number in the longest sequence\n    prev_num = [0] * (N + 1)\n\n    # Iterate over each number from 2 to N\n    for i in range(2, N + 1):\n        # Iterate over each divisor of the current number\n        for j in range(i - 1, 0, -1):\n            if i % j == 0:\n                # If the divisor is less than or equal to N and the sequence length can be increased\n                if longest_sequence[j] + 1 > longest_sequence[i]:\n                    longest_sequence[i] = longest_sequence[j] + 1\n                    prev_num[i] = j\n\n    # Find the maximum sequence length and the corresponding number\n    max_length = max(longest_sequence)\n    max_num = longest_sequence.index(max_length)\n\n    # Reconstruct the longest sequence\n    sequence = []\n    while max_num > 0:\n        sequence.append(max_num)\n        max_num = prev_num[max_num]\n\n    # Print the length and the sequence\n    print(max_length)\n    print(' '.join(map(str, sequence[::-1])))\n\nif __name__ == '__main__':\n    main()\n", "initial_solution": "def main():\n    N = int(input())\n\n    # Initialize a list to store the longest sequence length for each number\n    longest_sequence = [1] * (N + 1)\n\n    # Initialize a list to store the previous number in the longest sequence\n    prev_num = [0] * (N + 1)\n\n    # Iterate over each number from 2 to N\n    for i in range(2, N + 1):\n        # Iterate over each divisor of the current number\n        for j in range(1, int(i ** 0.5) + 1):\n            if i % j == 0:\n                # If the divisor is less than or equal to N and the sequence length can be increased\n                if j <= N and longest_sequence[j] + 1 > longest_sequence[i]:\n                    longest_sequence[i] = longest_sequence[j] + 1\n                    prev_num[i] = j\n\n    # Find the maximum sequence length and the corresponding number\n    max_length = max(longest_sequence)\n    max_num = longest_sequence.index(max_length)\n\n    # Reconstruct the longest sequence\n    sequence = []\n    while max_num > 0:\n        sequence.append(max_num)\n        max_num = prev_num[max_num]\n\n    # Print the length and the sequence\n    print(max_length)\n    print(' '.join(map(str, sequence[::-1])))\n\nif __name__ == '__main__':\n    main()\n"}
{"task_id": "Open Source", "final_solution": "import sys\n\ndef main():\n    while True:\n        projects = {}\n        while True:\n            line = input()\n            if line == '1':\n                break\n            if line.isupper():\n                project_name = line\n                if project_name not in projects:\n                    projects[project_name] = set()\n            else:\n                if project_name in projects:\n                    projects[project_name].add(line)\n        \n        if not projects:\n            break\n        \n        for project, students in sorted(projects.items(), key=lambda x: (-len(x[1]), x[0])):\n            print(f\"{project} {len(students)}\")\n        print()  # Add an empty line between test cases\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    while True:\n        projects = {}\n        while True:\n            line = input()\n            if line == '1':\n                break\n            if line.isupper():\n                project_name = line\n                projects[project_name] = set()\n            else:\n                projects[project_name].add(line)\n        \n        if not projects:\n            break\n        \n        for project, students in sorted(projects.items(), key=lambda x: (-len(x[1]), x[0])):\n            print(f\"{project} {len(students)}\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Candy Distribution", "final_solution": "import math\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        k, c = map(int, input().split())\n        x = math.ceil((k * ((k * c) + 1) - 1) / c)\n        if x * c >= k * ((k * c) + 1) - 1:\n            print(x)\n        else:\n            print(\"IMPOSSIBLE\")\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    t = int(input())\n    for _ in range(t):\n        k, c = map(int, input().split())\n        x = (k * c) + 1\n        if x % c == 0:\n            print(x // c)\n        else:\n            print(\"IMPOSSIBLE\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Card Magic", "final_solution": "def main():\n    N, K, T = map(int, input().split())\n    MOD = 1000000009\n\n    # Create a 2D array to store the dynamic programming table\n    dp = [[0]*(T+1) for _ in range(N+1)]\n    dp[0][0] = 1\n\n    # Fill up the dynamic programming table\n    for i in range(1, N+1):\n        for j in range(1, T+1):\n            for k in range(1, min(j, K)+1):\n                dp[i][j] = (dp[i][j] + dp[i-1][j-k]) % MOD\n\n    # Print the result\n    print(dp[N][T])\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    N, K, T = map(int, input().split())\n    MOD = 1000000009\n\n    # Create a 2D array to store the dynamic programming table\n    dp = [[0]*(T+1) for _ in range(N+1)]\n    dp[0][0] = 1\n\n    # Fill up the dynamic programming table\n    for i in range(1, N+1):\n        for j in range(1, T+1):\n            for k in range(1, min(j, K)+1):\n                dp[i][j] = (dp[i][j] + dp[i-1][j-k]) % MOD\n\n    # Print the result\n    print(dp[N][T])\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Rimski", "final_solution": "def main():\n    roman_numerals = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100}\n    values = [roman_numerals[c] for c in input()]\n    values.sort(reverse=True)\n\n    result = ''\n    i = 0\n    while i < len(values):\n        if values[i] == 1:\n            if i + 1 < len(values) and values[i + 1] == 4:\n                result += 'IV'\n                i += 2\n            elif i + 1 < len(values) and values[i + 1] == 9:\n                result += 'IX'\n                i += 2\n            else:\n                result += 'I'\n                i += 1\n        elif values[i] == 4:\n            result += 'IV'\n            i += 1\n        elif values[i] == 5:\n            result += 'V'\n            i += 1\n        elif values[i] == 9:\n            result += 'IX'\n            i += 1\n        elif values[i] == 10:\n            if i + 1 < len(values) and values[i + 1] == 40:\n                result += 'XL'\n                i += 2\n            elif i + 1 < len(values) and values[i + 1] == 90:\n                result += 'XC'\n                i += 2\n            else:\n                result += 'X'\n                i += 1\n        elif values[i] == 40:\n            result += 'XL'\n            i += 1\n        elif values[i] == 50:\n            result += 'L'\n            i += 1\n        elif values[i] == 90:\n            result += 'XC'\n            i += 1\n        elif values[i] == 100:\n            result += 'C'\n            i += 1\n\n    print(result)\n\nif __name__ == '__main__':\n    main()\n", "initial_solution": "def main():\n    roman_numerals = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100}\n    numeral_values = sorted(roman_numerals.values(), reverse=True)\n    numeral_chars = sorted(roman_numerals.keys(), reverse=True)\n\n    s = input()\n    values = [roman_numerals[c] for c in s]\n    values.sort(reverse=True)\n\n    result = ''\n    for v in numeral_values:\n        while values and values[-1] <= v:\n            result += numeral_chars[numeral_values.index(v)]\n            values.pop()\n\n    print(result)\n\nif __name__ == '__main__':\n    main()\n"}
{"task_id": "Eko", "final_solution": "def main():\n    N, M = map(int, input().split())\n    trees = list(map(int, input().split()))\n\n    def can_cut(height):\n        total_wood = sum(max(0, tree - height) for tree in trees)\n        return total_wood >= M\n\n    low, high = 0, max(trees)\n    while low < high:\n        mid = (low + high + 1) // 2\n        if can_cut(mid):\n            low = mid\n        else:\n            high = mid - 1\n\n    print(low)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    N, M = map(int, input().split())\n    trees = list(map(int, input().split()))\n\n    def can_cut(height):\n        total_wood = sum(max(0, tree - height) for tree in trees)\n        return total_wood >= M\n\n    low, high = 0, max(trees)\n    while low < high:\n        mid = (low + high + 1) // 2\n        if can_cut(mid):\n            low = mid\n        else:\n            high = mid - 1\n\n    print(low)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Font", "final_solution": "from collections import Counter\nfrom math import factorial\nfrom itertools import combinations\n\ndef main():\n    N = int(input())\n    words = [input() for _ in range(N)]\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    word_chars = [set(word) for word in words]\n    total_chars = set.union(*word_chars)\n    if len(total_chars) < 26:\n        print(0)\n        return\n    char_counts = Counter(char for word in words for char in word)\n    test_sentences = 0\n    for i in range(N, 0, -1):\n        if all(char_counts[char] >= i for char in alphabet):\n            test_sentences = factorial(i) // (factorial(i - 26) * factorial(26))\n            break\n    print(test_sentences)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "from collections import Counter\nfrom math import factorial\n\ndef main():\n    N = int(input())\n    words = [input() for _ in range(N)]\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    word_chars = [set(word) for word in words]\n    total_chars = set.union(*word_chars)\n    if len(total_chars) < 26:\n        print(0)\n        return\n    char_counts = Counter(char for word in words for char in word)\n    test_sentences = 0\n    for i in range(N, 0, -1):\n        if all(char_counts[char] >= i for char in alphabet):\n            test_sentences = factorial(i) // (factorial(i - N) * factorial(N))\n            break\n    print(test_sentences)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Toys", "final_solution": "def main():\n    T, K = map(int, input().split())\n    position = (K - 1) % (T - 1)\n    print(position + 1 if position != 0 else T)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    T, K = map(int, input().split())\n    position = (K - 1) % T\n    print(position)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Where to Live?", "final_solution": "def main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        x_coords = []\n        y_coords = []\n        for _ in range(n):\n            x, y = map(int, input().split())\n            x_coords.append(x)\n            y_coords.append(y)\n        \n        avg_x = sum(x_coords) / n\n        avg_y = sum(y_coords) / n\n        \n        best_x = round(avg_x)\n        best_y = round(avg_y)\n        \n        if abs(best_x - avg_x) > 0.5:\n            best_x = best_x + 1 if avg_x > best_x else best_x - 1\n        if abs(best_y - avg_y) > 0.5:\n            best_y = best_y + 1 if avg_y > best_y else best_y - 1\n        \n        print(f\"{best_x} {best_y}\")\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        x_coords = []\n        y_coords = []\n        for _ in range(n):\n            x, y = map(int, input().split())\n            x_coords.append(x)\n            y_coords.append(y)\n        \n        avg_x = sum(x_coords) / n\n        avg_y = sum(y_coords) / n\n        \n        best_x = round(avg_x)\n        best_y = round(avg_y)\n        \n        if abs(best_x - avg_x) > 0.5:\n            best_x = best_x + 1 if avg_x > best_x else best_x - 1\n        if abs(best_y - avg_y) > 0.5:\n            best_y = best_y + 1 if avg_y > best_y else best_y - 1\n        \n        print(f\"{best_x} {best_y}\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Greeting Card", "final_solution": "def main():\n    n = int(input())\n    points = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        points.append((x, y))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            dx = points[i][0] - points[j][0]\n            dy = points[i][1] - points[j][1]\n            dist = (dx ** 2 + dy ** 2) ** 0.5\n            if dist == 2018:\n                count += 1\n\n    print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    n = int(input())\n    points = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        points.append((x, y))\n\n    count = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            dx = points[i][0] - points[j][0]\n            dy = points[i][1] - points[j][1]\n            dist = (dx ** 2 + dy ** 2) ** 0.5\n            if dist == 2018:\n                count += 1\n\n    print(count)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Robert Hood", "final_solution": "import math\n\ndef main():\n    # Take user input for the number of shots\n    C = int(input())\n\n    # Initialize a list to store the coordinates of the shots\n    shots = []\n\n    # Take user input for the coordinates of each shot\n    for _ in range(C):\n        x, y = map(int, input().split())\n        shots.append((x, y))\n\n    # Initialize the maximum distance to 0\n    max_distance = 0\n\n    # Iterate over each pair of shots\n    for i in range(len(shots)):\n        for j in range(i + 1, len(shots)):\n            # Calculate the distance between the two shots\n            distance = math.sqrt((shots[i][0] - shots[j][0]) ** 2 + (shots[i][1] - shots[j][1]) ** 2)\n            # Update the maximum distance if the current distance is greater\n            max_distance = max(max_distance, distance)\n\n    # Print the maximum distance\n    print(max_distance)\n\nif __name__ == '__main__':\n    main()\n", "initial_solution": "import math\n\ndef main():\n    # Take user input for the number of shots\n    C = int(input())\n\n    # Initialize a list to store the coordinates of the shots\n    shots = []\n\n    # Take user input for the coordinates of each shot\n    for _ in range(C):\n        x, y = map(int, input().split())\n        shots.append((x, y))\n\n    # Initialize the maximum distance to 0\n    max_distance = 0\n\n    # Iterate over each pair of shots\n    for i in range(len(shots)):\n        for j in range(i + 1, len(shots)):\n            # Calculate the distance between the two shots\n            distance = math.sqrt((shots[i][0] - shots[j][0]) ** 2 + (shots[i][1] - shots[j][1]) ** 2)\n            # Update the maximum distance if the current distance is greater\n            max_distance = max(max_distance, distance)\n\n    # Print the maximum distance\n    print(max_distance)\n\nif __name__ == '__main__':\n    main()\n"}
{"task_id": "Perica", "final_solution": "\nimport math\n\ndef main():\n    N, K = map(int, input().split())\n    keys = list(map(int, input().split()))\n    keys.sort(reverse=True)\n    ans = sum(keys[:K]) % 1000000007\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    N, K = map(int, input().split())\n    keys = list(map(int, input().split()))\n    keys.sort(reverse=True)\n    ans = sum(keys[:K])\n    print(ans % 1000000007)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Digbuild", "final_solution": "def main():\n    n = int(input())\n    MOD = 10**9 + 7\n\n    # Initialize the base cases\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 4\n\n    # Calculate the number of non-ugly torch arrangements for each tunnel length\n    for i in range(2, n + 1):\n        dp[i] = (2 * dp[i - 1] + 2 * dp[i - 2]) % MOD\n\n    print(dp[n])\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    n = int(input())\n    MOD = 10**9 + 7\n\n    # Initialize the base cases\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    dp[1] = 2\n\n    # Calculate the number of non-ugly torch arrangements for each tunnel length\n    for i in range(2, n + 1):\n        dp[i] = (2 * dp[i - 1] + dp[i - 2]) % MOD\n\n    print(dp[n])\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Crane", "final_solution": "import sys\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        n = int(input())\n        crates = list(map(int, input().split()))\n        swaps = 0\n        intervals = []\n        for i in range(n):\n            if crates[i] != i + 1:\n                j = i + 1\n                while j < n and crates[j] != i + 1:\n                    j += 1\n                if j - i > 1:\n                    intervals.append((i + 1, j))\n                    swaps += 1\n                crates[i:j] = crates[i:j][::-1]\n        print(swaps)\n        for interval in intervals:\n            print(interval[0], interval[1])\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    T = int(input())\n    for _ in range(T):\n        n = int(input())\n        crates = list(map(int, input().split()))\n        swaps = 0\n        intervals = []\n        for i in range(n):\n            if crates[i] != i + 1:\n                j = i + 1\n                while j < n and crates[j] != i + 1:\n                    j += 1\n                if j - i > 1:\n                    intervals.append((i + 1, j))\n                    swaps += 1\n                crates[i:j] = crates[i:j][::-1]\n        print(swaps)\n        for interval in intervals:\n            print(interval[0], interval[1])\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Movie Collection", "final_solution": "def main():\n    T = int(input())\n    for _ in range(T):\n        m, r = map(int, input().split())\n        a = list(map(int, input().split()))\n        stack = list(range(1, m + 1))\n        ans = []\n        for x in a:\n            idx = stack.index(x)\n            ans.append(idx)\n            stack.pop(idx)\n            stack.insert(0, x)\n        print(' '.join(map(str, ans)))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    T = int(input())\n    for _ in range(T):\n        m, r = map(int, input().split())\n        a = list(map(int, input().split()))\n        stack = list(range(1, m + 1))\n        ans = []\n        for x in a:\n            idx = stack.index(x)\n            ans.append(idx)\n            stack.pop(idx)\n            stack.insert(0, x)\n        print(' '.join(map(str, ans)))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Judo Championship", "final_solution": "import sys\nfrom collections import defaultdict\n\ndef main():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    ans = ['0'] * m\n    for i in range(m):\n        u, v = map(int, input().split())\n        if len(graph[u]) > len(graph[v]):\n            ans[i] = '1'\n        else:\n            ans[i] = '0'\n\n    print(''.join(ans))\n\nif __name__ == '__main__':\n    main()\n", "initial_solution": "def main():\n    n, m = map(int, input().split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    ans = ['0'] * m\n    for i in range(m):\n        u, v = map(int, input().split())\n        if len(graph[u]) > len(graph[v]):\n            ans[i] = '1'\n        else:\n            ans[i] = '0'\n\n    print(''.join(ans))\n\nif __name__ == '__main__':\n    main()\n"}
{"task_id": "Programming Tutors", "final_solution": "def main():\n    n = int(input())\n    students = []\n    tutors = []\n    \n    for _ in range(n):\n        x, y = map(int, input().split())\n        students.append((x, y))\n    \n    for _ in range(n):\n        x, y = map(int, input().split())\n        tutors.append((x, y))\n    \n    students.sort()\n    tutors.sort()\n    \n    max_distance = 0\n    for i in range(n):\n        distance = abs(students[i][0] - tutors[i][0]) + abs(students[i][1] - tutors[i][1])\n        max_distance = max(max_distance, distance)\n    \n    print(max_distance)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    n = int(input())\n    students = []\n    tutors = []\n    \n    for _ in range(n):\n        x, y = map(int, input().split())\n        students.append((x, y))\n    \n    for _ in range(n):\n        x, y = map(int, input().split())\n        tutors.append((x, y))\n    \n    students.sort()\n    tutors.sort()\n    \n    max_distance = 0\n    for i in range(n):\n        distance = abs(students[i][0] - tutors[i][0]) + abs(students[i][1] - tutors[i][1])\n        max_distance = max(max_distance, distance)\n    \n    print(max_distance)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "King's Colors", "final_solution": "MOD = 1000000007\ndef main():\n    n, k = map(int, input().split())\n    graph = [[] for _ in range(n)]\n    for i in range(1, n):\n        p = int(input())\n        graph[p].append(i)\n\n    dp = [0] * (k + 1)\n    dp[0] = 1\n\n    for i in range(n):\n        ndp = [0] * (k + 1)\n        for j in range(1, k + 1):\n            for child in graph[i]:\n                ndp[j] = (ndp[j] + dp[j - 1] * (j - 1) % MOD) % MOD\n            if j > 1:\n                ndp[j] = (ndp[j] + dp[j] * (j - 1) % MOD) % MOD\n        dp = ndp\n\n    print(sum(dp[1:]) % MOD)\n\nif __name__ == '__main__':\n    main()\n", "initial_solution": "def main():\n    MOD = 1000000007\n    n, k = map(int, input().split())\n    graph = [[] for _ in range(n)]\n    for _ in range(n - 1):\n        p = int(input())\n        graph[p].append(_)\n\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(n):\n        for j in range(k, 0, -1):\n            for child in graph[i]:\n                dp[child][j] = (dp[child][j] + dp[i][j - 1]) % MOD\n\n    print(sum(dp[0][1:]) % MOD)\n\nif __name__ == '__main__':\n    main()\n"}
{"task_id": "Digit Division", "final_solution": "MOD = 10**9 + 7\ndef main():\n    n, m = map(int, input().split())\n    s = input()\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(n):\n        num = 0\n        for j in range(i, -1, -1):\n            num = num * 10 + int(s[j])\n            if num % m == 0:\n                dp[i + 1] += dp[j]\n                dp[i + 1] %= MOD\n    print(dp[-1] % MOD)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    MOD = 10**9 + 7\n    n, m = map(int, input().split())\n    s = input()\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(n):\n        num = 0\n        for j in range(i, -1, -1):\n            num = num * 10 + int(s[j])\n            if num % m == 0:\n                dp[i + 1] += dp[j]\n                dp[i + 1] %= MOD\n    print(dp[-1])\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Contest Advancement", "final_solution": "from collections import defaultdict\n\ndef main():\n    n, k, c = map(int, input().split())\n    teams = []\n    for _ in range(n):\n        t, s = map(int, input().split())\n        teams.append((t, s))\n    \n    teams.sort(reverse=True)\n    school_count = defaultdict(int)\n    qualified_teams = []\n    \n    for t, s in teams:\n        if school_count[s] < c:\n            qualified_teams.append(t)\n            school_count[s] += 1\n            k -= 1\n            if k == 0:\n                break\n        if k == 0:\n            break\n    \n    for t in sorted(qualified_teams, reverse=True):\n        print(t)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    n, k, c = map(int, input().split())\n    teams = []\n    for _ in range(n):\n        t, s = map(int, input().split())\n        teams.append((t, s))\n    \n    teams.sort(key=lambda x: x[0])\n    school_count = defaultdict(int)\n    qualified_teams = []\n    \n    for t, s in teams:\n        if school_count[s] < c:\n            qualified_teams.append(t)\n            school_count[s] += 1\n            k -= 1\n            if k == 0:\n                break\n        else:\n            qualified_teams.append(t)\n            k -= 1\n            if k == 0:\n                break\n    \n    for t in qualified_teams:\n        print(t)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Swap Space", "final_solution": "import sys\n\ndef solve():\n    n = int(input())\n    S = [list(map(int, input().split())) for _ in range(n)]\n    S.sort(key=lambda x: x[0] - x[1])\n    extra_capacity = 0\n    total_capacity = sum(a for a, _ in S)\n    remaining_capacity = total_capacity\n    for a, b in S:\n        if b > a:\n            remaining_capacity -= b - a\n            extra_capacity += max(0, b - a)\n        else:\n            remaining_capacity -= a - b\n    print(max(0, extra_capacity - remaining_capacity))\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        solve()\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    n = int(input())\n    drives = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        drives.append((a, b))\n    \n    drives.sort(key=lambda x: x[0] - x[1])\n    \n    extra_capacity = 0\n    total_capacity = 0\n    for a, b in drives:\n        total_capacity += a\n        extra_capacity += max(0, b - a)\n    \n    print(max(0, total_capacity - sum(b for _, b in drives)) + extra_capacity)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Road To Savings", "final_solution": "import heapq\n\ndef main():\n    n, m, a, b = map(int, input().split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        i1, i2, l = map(int, input().split())\n        graph[i1].append((l, i2))\n        graph[i2].append((l, i1))\n\n    def dijkstra(start):\n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n        pq = [(0, start)]\n        while pq:\n            d, node = heapq.heappop(pq)\n            if d > dist[node]:\n                continue\n            for l, neighbor in graph[node]:\n                if d + l < dist[neighbor]:\n                    dist[neighbor] = d + l\n                    heapq.heappush(pq, (d + l, neighbor))\n        return dist\n\n    dist_a = dijkstra(a)\n    dist_b = dijkstra(b)\n    total_length = sum(l for i in range(1, n + 1) for l, _ in graph[i])\n    min_length = min(dist_a[b], dist_b[a])\n    roads_to_pave = [i for i in range(1, n + 1) if dist_a[i] + dist_b[i] == min_length]\n    total_length -= sum(l for i in roads_to_pave for l, j in graph[i] if j in roads_to_pave)\n    print(total_length)\n\nif __name__ == '__main__':\n    main()\n", "initial_solution": "import heapq\n\ndef main():\n    n, m, a, b = map(int, input().split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        i1, i2, l = map(int, input().split())\n        graph[i1].append((l, i2))\n        graph[i2].append((l, i1))\n\n    def dijkstra(start):\n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n        pq = [(0, start)]\n        while pq:\n            d, node = heapq.heappop(pq)\n            if d > dist[node]:\n                continue\n            for l, neighbor in graph[node]:\n                if d + l < dist[neighbor]:\n                    dist[neighbor] = d + l\n                    heapq.heappush(pq, (d + l, neighbor))\n        return dist\n\n    dist_a = dijkstra(a)\n    dist_b = dijkstra(b)\n    total_length = sum(l for i in range(1, n + 1) for l, _ in graph[i])\n    min_length = dist_a[b]\n    total_length -= min_length\n    print(total_length)\n\nif __name__ == '__main__':\n    main()\n"}
{"task_id": "Closest Pair (Uniform)", "final_solution": "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef brute_force_closest_pair(points):\n    min_dist = float('inf')\n    closest_pair = None\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            dist = distance(points[i], points[j])\n            if dist < min_dist:\n                min_dist = dist\n                closest_pair = (points[i], points[j])\n    return closest_pair\n\ndef closest_pair(points):\n    points.sort(key=lambda x: x[0])\n    return _closest_pair(points)\n\ndef _closest_pair(points):\n    if len(points) <= 3:\n        return brute_force_closest_pair(points)\n    mid = len(points) // 2\n    left_closest_pair = _closest_pair(points[:mid])\n    right_closest_pair = _closest_pair(points[mid:])\n    min_dist = min(distance(*left_closest_pair), distance(*right_closest_pair))\n    closest_pair = left_closest_pair if distance(*left_closest_pair) < distance(*right_closest_pair) else right_closest_pair\n    mid_points = [point for point in points if abs(point[0] - points[mid][0]) < min_dist]\n    mid_points.sort(key=lambda x: x[1])\n    for i in range(len(mid_points)):\n        for j in range(i + 1, min(i + 7, len(mid_points))):\n            dist = distance(mid_points[i], mid_points[j])\n            if dist < min_dist:\n                min_dist = dist\n                closest_pair = (mid_points[i], mid_points[j])\n    return closest_pair\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        points = []\n        for _ in range(n):\n            x, y = map(float, input().split())\n            points.append((x, y))\n        closest_pair = closest_pair(points)\n        print(f\"{closest_pair[0][0]:.2f} {closest_pair[0][1]:.2f} {closest_pair[1][0]:.2f} {closest_pair[1][1]:.2f}\")\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef brute_force_closest_pair(points):\n    min_dist = float('inf')\n    closest_pair = None\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            dist = distance(points[i], points[j])\n            if dist < min_dist:\n                min_dist = dist\n                closest_pair = (points[i], points[j])\n    return closest_pair\n\ndef closest_pair(points):\n    points.sort(key=lambda x: x[0])\n    return _closest_pair(points)\n\ndef _closest_pair(points):\n    if len(points) <= 3:\n        return brute_force_closest_pair(points)\n    mid = len(points) // 2\n    left_closest_pair = _closest_pair(points[:mid])\n    right_closest_pair = _closest_pair(points[mid:])\n    min_dist = min(distance(*left_closest_pair), distance(*right_closest_pair))\n    closest_pair = left_closest_pair if distance(*left_closest_pair) < distance(*right_closest_pair) else right_closest_pair\n    mid_points = [point for point in points if abs(point[0] - points[mid][0]) < min_dist]\n    mid_points.sort(key=lambda x: x[1])\n    for i in range(len(mid_points)):\n        for j in range(i + 1, min(i + 7, len(mid_points))):\n            dist = distance(mid_points[i], mid_points[j])\n            if dist < min_dist:\n                min_dist = dist\n                closest_pair = (mid_points[i], mid_points[j])\n    return closest_pair\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        points = []\n        for _ in range(n):\n            x, y = map(float, input().split())\n            points.append((x, y))\n        closest_pair = closest_pair(points)\n        print(f\"{closest_pair[0][0]:.2f} {closest_pair[0][1]:.2f} {closest_pair[1][0]:.2f} {closest_pair[1][1]:.2f}\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Lost in Translation", "final_solution": "import heapq\n\ndef main():\n    n, m = map(int, input().split())\n    languages = input().split()\n    graph = {lang: {} for lang in languages}\n    graph['English'] = {}\n\n    for _ in range(m):\n        l1, l2, c = input().split()\n        c = int(c)\n        graph[l1][l2] = c\n        graph[l2][l1] = c\n\n    pq = [(0, 'English')]\n    dist = {lang: float('inf') for lang in languages}\n    dist['English'] = 0\n\n    while pq:\n        d, lang = heapq.heappop(pq)\n        if d > dist[lang]:\n            continue\n        for neighbor, c in graph[lang].items():\n            if d + c < dist[neighbor]:\n                dist[neighbor] = d + c\n                heapq.heappush(pq, (d + c, neighbor))\n\n    if all(d != float('inf') for d in dist.values()):\n        print(sum(d for d in dist.values() if d != 0))\n    else:\n        print('Impossible')\n\nif __name__ == '__main__':\n    main()\n", "initial_solution": "import heapq\n\ndef main():\n    n, m = map(int, input().split())\n    languages = input().split()\n    graph = {lang: {} for lang in languages}\n    graph['English'] = {}\n\n    for _ in range(m):\n        l1, l2, c = input().split()\n        c = int(c)\n        graph[l1][l2] = c\n        graph[l2][l1] = c\n\n    pq = [(0, 'English')]\n    dist = {lang: float('inf') for lang in languages}\n    dist['English'] = 0\n\n    while pq:\n        d, lang = heapq.heappop(pq)\n        if d > dist[lang]:\n            continue\n        for neighbor, c in graph[lang].items():\n            if d + c < dist[neighbor]:\n                dist[neighbor] = d + c\n                heapq.heappush(pq, (d + c, neighbor))\n\n    total_cost = sum(dist.values())\n    if total_cost == float('inf'):\n        print('Impossible')\n    else:\n        print(total_cost)\n\nif __name__ == '__main__':\n    main()\n"}
{"task_id": "Six Degrees", "final_solution": "from collections import deque, defaultdict\n\ndef bfs(graph, start):\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        node, distance = queue.popleft()\n        if node not in visited:\n            visited.add(node)\n            if distance > 5:\n                return False\n            for neighbor in graph[node]:\n                queue.append((neighbor, distance + 1))\n    return True\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        M = int(input())\n        graph = defaultdict(list)\n        for _ in range(M):\n            u, v = input().split()\n            graph[u].append(v)\n            graph[v].append(u)\n        devices_to_disconnect = 0\n        for node in list(graph.keys()):  # Create a copy of the keys\n            temp_graph = {k: v[:] for k, v in graph.items()}  # Create a deep copy of the graph\n            temp_graph.pop(node)\n            for neighbor in graph[node]:\n                temp_graph[neighbor].remove(node)\n            if not all(bfs(temp_graph, n) for n in temp_graph):\n                devices_to_disconnect += 1\n        if devices_to_disconnect / len(graph) <= 0.05:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "from collections import deque\n\ndef bfs(graph, start):\n    queue = deque([(start, 0)])\n    visited = set()\n    while queue:\n        node, distance = queue.popleft()\n        if node not in visited:\n            visited.add(node)\n            if distance > 5:\n                return False\n            for neighbor in graph[node]:\n                queue.append((neighbor, distance + 1))\n    return True\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        M = int(input())\n        graph = defaultdict(list)\n        for _ in range(M):\n            u, v = input().split()\n            graph[u].append(v)\n            graph[v].append(u)\n        devices_to_disconnect = 0\n        for node in graph:\n            if not bfs(graph, node):\n                devices_to_disconnect += 1\n        if devices_to_disconnect / len(graph) <= 0.05:\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Screamers in the Storm", "final_solution": "def main():\n    K, N = map(int, input().split())\n    MOD = 10**9 + 7\n\n    # Initialize a list to store the number of configurations for each length of dunes\n    dp = [0] * (K + 1)\n    dp[0] = 1\n\n    # Iterate over each length of dunes\n    for _ in range(N):\n        # Initialize a new list to store the number of configurations for the current length of dunes\n        new_dp = [0] * (K + 1)\n        # Iterate over each possible height of dunes\n        for i in range(1, K + 1):\n            # Calculate the number of configurations for the current length of dunes\n            for j in range(i, K + 1):\n                new_dp[j] += dp[j - i]\n                new_dp[j] %= MOD\n        dp = new_dp\n\n    # Print the number of different strings of dunes\n    print(dp[K])\n\nif __name__ == '__main__':\n    main()\n", "initial_solution": "def main():\n    K, N = map(int, input().split())\n    MOD = 10**9 + 7\n\n    # Initialize a list to store the number of configurations for each length of dunes\n    dp = [0] * (N + 1)\n    dp[0] = 1\n\n    # Iterate over each possible height of dunes\n    for i in range(1, K + 1):\n        # Iterate over each length of dunes\n        for j in range(i, N + 1):\n            # Calculate the number of configurations for the current length of dunes\n            dp[j] += dp[j - i]\n            dp[j] %= MOD\n\n    # Print the number of different strings of dunes\n    print(dp[N])\n\nif __name__ == '__main__':\n    main()\n"}
{"task_id": "Ferry Loading III", "final_solution": "def main():\n    c = int(input())\n    for _ in range(c):\n        n, t, m = map(int, input().split())\n        cars = []\n        for _ in range(m):\n            time, bank = input().split()\n            time = int(time)\n            cars.append((time, bank))\n        cars.sort()\n        ferry_time = 0\n        left_queue = []\n        right_queue = []\n        for time, bank in cars:\n            if bank == \"left\":\n                left_queue.append(time)\n            else:\n                right_queue.append(time)\n        left_queue.sort()\n        right_queue.sort()\n        ferry_load = []\n        ferry_bank = \"left\"\n        while left_queue or right_queue or ferry_load:\n            if ferry_bank == \"left\":\n                while left_queue and len(ferry_load) < n:\n                    ferry_load.append(left_queue.pop(0))\n            else:\n                while right_queue and len(ferry_load) < n:\n                    ferry_load.append(right_queue.pop(0))\n            if ferry_load:\n                ferry_time = max(ferry_time, min(ferry_load))\n                for _ in range(len(ferry_load)):\n                    print(ferry_time + t)\n                ferry_load = []\n                ferry_time += t\n            if ferry_bank == \"left\":\n                ferry_bank = \"right\"\n            else:\n                ferry_bank = \"left\"\n        print()\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    c = int(input())\n    for _ in range(c):\n        n, t, m = map(int, input().split())\n        cars = []\n        for _ in range(m):\n            time, bank = input().split()\n            time = int(time)\n            cars.append((time, bank))\n        cars.sort()\n        ferry_time = 0\n        left_queue = []\n        right_queue = []\n        for time, bank in cars:\n            if bank == \"left\":\n                left_queue.append(time)\n            else:\n                right_queue.append(time)\n        while left_queue or right_queue:\n            if left_queue:\n                ferry_time = max(ferry_time, left_queue[0])\n                left_queue[0] += t\n                print(left_queue.pop(0) + t)\n            else:\n                ferry_time = max(ferry_time, right_queue[0])\n                right_queue[0] += t\n                print(right_queue.pop(0) + t)\n            if right_queue:\n                ferry_time = max(ferry_time, right_queue[0])\n                right_queue[0] += t\n                print(right_queue.pop(0) + t)\n            else:\n                ferry_time = max(ferry_time, left_queue[0])\n                left_queue[0] += t\n                print(left_queue.pop(0) + t)\n        print()\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "A Classy Problem", "final_solution": "def main():\n    T = int(input())\n    for _ in range(T):\n        n = int(input())\n        people = []\n        for _ in range(n):\n            name, class_str = input().split(': ')\n            class_str = class_str.replace(' class', '')\n            class_list = class_str.split('-')\n            people.append((name, class_list))\n        \n        people.sort(key=lambda x: ([-i in ['upper', 'middle', 'lower'] for i in x[1]].count('lower'), \n                                    [-i in ['upper', 'middle', 'lower'] for i in x[1]].count('middle'), \n                                    [i in ['upper', 'middle', 'lower'] for i in x[1]].count('upper'), \n                                    x[0]))\n        \n        for name, _ in people:\n            print(name)\n        print(\"==============================\")\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    T = int(input())\n    for _ in range(T):\n        n = int(input())\n        people = []\n        for _ in range(n):\n            name, class_str = input().split(': ')\n            class_str = class_str.replace(' class', '')\n            class_list = class_str.split('-')\n            people.append((name, class_list))\n        \n        people.sort(key=lambda x: (-len(x[1]), x[1], x[0]))\n        \n        for name, _ in people:\n            print(name)\n        print(\"==============================\")\n\nif __name__ == \"__main__\":\n    main()\n"}
