{"task_id": "Bribe", "final_solution": "import unittest\nfrom unittest.mock import patch\nfrom io import StringIO\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        n, c, m = map(int, input().split())\n        henchmen = []\n        for _ in range(n):\n            b, p = map(int, input().split())\n            henchmen.append((b, p / 100))\n        henchmen.sort()\n        dp = [[0.0] * (m + 1) for _ in range(c + 1)]\n        dp[0][0] = 1.0\n        for i in range(1, c + 1):\n            for j in range(1, m + 1):\n                dp[i][j] = dp[i][j - 1]\n                for k, (b, p) in enumerate(henchmen):\n                    if b <= j:\n                        dp[i][j] = max(dp[i][j], dp[i - 1][j - b] * p + dp[i][j - b] * (1 - p))\n        print(\"{:.6f}\".format(dp[c][m]))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    T = int(input())\n    for _ in range(T):\n        n, c, m = map(int, input().split())\n        henchmen = []\n        for _ in range(n):\n            b, p = map(int, input().split())\n            henchmen.append((b, p / 100))\n        henchmen.sort(reverse=True)\n        dp = [[0.0] * (m + 1) for _ in range(c + 1)]\n        dp[0][0] = 1.0\n        for i in range(1, c + 1):\n            for j in range(1, m + 1):\n                dp[i][j] = dp[i][j - 1]\n                for k, (b, p) in enumerate(henchmen):\n                    if b <= j:\n                        dp[i][j] = max(dp[i][j], dp[i - 1][j - b] * p)\n        print(\"{:.6f}\".format(dp[c][m]))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Classrooms", "final_solution": "import sys\n\ndef main():\n    n, k = map(int, input().split())\n    activities = []\n    for _ in range(n):\n        start, end = map(int, input().split())\n        activities.append((start, end))\n    \n    activities.sort(key=lambda x: x[1])\n    \n    count = 0\n    end_time = 0\n    for start, end in activities:\n        if start >= end_time:\n            count += 1\n            end_time = end\n            if count == k:\n                break\n    \n    print(min(count, k))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    n, k = map(int, input().split())\n    activities = []\n    for _ in range(n):\n        start, end = map(int, input().split())\n        activities.append((start, end))\n    \n    activities.sort(key=lambda x: x[1])\n    \n    count = 0\n    end_time = 0\n    for start, end in activities:\n        if start >= end_time:\n            count += 1\n            end_time = end\n    \n    print(count)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "You Be the Judge!", "final_solution": "import sys\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef main():\n    lines = []\n    for line in sys.stdin:\n        lines.append(line)\n    nums = ' '.join(lines).split()\n    nums = [num for num in nums if num]  # remove empty strings\n    if len(nums) != 3:\n        print(0)\n        return\n\n    n, p, q = map(int, nums)\n    if n % 2 != 0 or n < 4 or n > 10**9:\n        print(0)\n        return\n    if not is_prime(p) or not is_prime(q) or p + q != n:\n        print(0)\n        return\n\n    print(1)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def is_prime(n):\n    if n <= 1:\n        return False\n    if n <= 3:\n        return True\n    if n % 2 == 0 or n % 3 == 0:\n        return False\n    i = 5\n    while i * i <= n:\n        if n % i == 0 or n % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\ndef main():\n    lines = []\n    while True:\n        line = input()\n        if line.strip() == \"\":\n            continue\n        lines.append(line)\n        if len(lines) == 1:\n            break\n\n    nums = lines[0].split()\n    if len(nums) != 3:\n        print(0)\n        return\n\n    n, p, q = map(int, nums)\n    if n % 2 != 0 or n < 4 or n > 10**9:\n        print(0)\n        return\n    if not is_prime(p) or not is_prime(q) or p + q != n:\n        print(0)\n        return\n\n    print(1)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Tour Guide", "final_solution": "import math\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        v = float(input())\n        max_time = 0\n        for _ in range(n):\n            x, y, vi, a = map(float, input().split())\n            d = math.hypot(x, y)\n            t = d / vi\n            max_time = max(max_time, t)\n        print(math.ceil(max_time / v))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import math\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        v = float(input())\n        max_time = 0\n        for _ in range(n):\n            x, y, vi, a = map(float, input().split())\n            a = math.atan2(y, x)\n            d = math.hypot(x, y)\n            t = d / (v - vi * math.cos(a))\n            if t > 0:\n                max_time = max(max_time, math.ceil(t))\n        print(max_time)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Hot Spot", "final_solution": "from collections import deque\n\ndef main():\n    # Read the input board\n    board = [input() for _ in range(4)]\n\n    # Find the initial position of the red robot\n    for i in range(4):\n        for j in range(4):\n            if board[i][j] == 'R':\n                red_x, red_y = i, j\n                break\n\n    # Initialize the queue for BFS and the visited set\n    queue = deque([(red_x, red_y, 0)])  # (x, y, jumps)\n    visited = {(red_x, red_y)}\n\n    # Directions for moving the robots\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    while queue:\n        x, y, jumps = queue.popleft()\n\n        # If the red robot reaches the top left corner, return the number of jumps\n        if x == 0 and y == 0:\n            print(jumps)\n            return\n\n        # Try to move the robots\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n\n            # Check if the new position is within the board\n            if 0 <= nx < 4 and 0 <= ny < 4:\n                # Check if the new position is empty\n                if board[nx][ny] == '.':\n                    # Try to jump over another robot\n                    for ddx, ddy in directions:\n                        nnx, nny = nx + ddx, ny + ddy\n\n                        # Check if the robot to jump over is within the board\n                        if 0 <= nnx < 4 and 0 <= nny < 4:\n                            # Check if the robot to jump over is not blue and not the red robot\n                            if board[nnx][nny] != 'B' and (nnx, nny) != (x, y):\n                                # Check if the position after jumping is not visited\n                                if (nx, ny) not in visited:\n                                    queue.append((nx, ny, jumps + 1))\n                                    visited.add((nx, ny))\n\n                # Try to jump over two robots\n                for ddx, ddy in directions:\n                    nnx, nny = nx + ddx, ny + ddy\n                    nnnx, nnny = nx + 2 * ddx, ny + 2 * ddy\n\n                    # Check if the robots to jump over are within the board\n                    if 0 <= nnx < 4 and 0 <= nny < 4 and 0 <= nnnx < 4 and 0 <= nnny < 4:\n                        # Check if the robots to jump over are not blue and not the red robot\n                        if board[nnx][nny] != 'B' and board[nnnx][nnny] != 'B' and (nnx, nny) != (x, y) and (nnnx, nnny) != (x, y):\n                            # Check if the position after jumping is not visited\n                            if (nx, ny) not in visited:\n                                queue.append((nx, ny, jumps + 1))\n                                visited.add((nx, ny))\n\n    # If the red robot cannot reach the top left corner, print -1\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "from collections import deque\n\ndef main():\n    # Read the input board\n    board = [input() for _ in range(4)]\n\n    # Find the initial position of the red robot\n    for i in range(4):\n        for j in range(4):\n            if board[i][j] == 'R':\n                red_x, red_y = i, j\n                break\n\n    # Initialize the queue for BFS and the visited set\n    queue = deque([(red_x, red_y, 0)])  # (x, y, jumps)\n    visited = {(red_x, red_y)}\n\n    # Directions for moving the robots\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n\n    while queue:\n        x, y, jumps = queue.popleft()\n\n        # If the red robot reaches the top left corner, return the number of jumps\n        if x == 0 and y == 0:\n            print(jumps)\n            return\n\n        # Try to move the robots\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n\n            # Check if the new position is within the board\n            if 0 <= nx < 4 and 0 <= ny < 4:\n                # Check if the new position is empty\n                if board[nx][ny] == '.':\n                    # Try to jump over another robot\n                    for ddx, ddy in directions:\n                        nnx, nny = nx + ddx, ny + ddy\n\n                        # Check if the robot to jump over is within the board\n                        if 0 <= nnx < 4 and 0 <= nny < 4:\n                            # Check if the robot to jump over is not blue and not the red robot\n                            if board[nnx][nny] != 'B' and (nnx, nny) != (x, y):\n                                # Check if the position after jumping is not visited\n                                if (nx, ny) not in visited:\n                                    queue.append((nx, ny, jumps + 1))\n                                    visited.add((nx, ny))\n\n                # Try to jump over two robots\n                for ddx, ddy in directions:\n                    nnx, nny = nx + ddx, ny + ddy\n                    nnnx, nnny = nx + 2 * ddx, ny + 2 * ddy\n\n                    # Check if the robots to jump over are within the board\n                    if 0 <= nnx < 4 and 0 <= nny < 4 and 0 <= nnnx < 4 and 0 <= nnny < 4:\n                        # Check if the robots to jump over are not blue and not the red robot\n                        if board[nnx][nny] != 'B' and board[nnnx][nnny] != 'B' and (nnx, nny) != (x, y) and (nnnx, nnny) != (x, y):\n                            # Check if the position after jumping is not visited\n                            if (nx, ny) not in visited:\n                                queue.append((nx, ny, jumps + 1))\n                                visited.add((nx, ny))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Treasure Map", "final_solution": "import math\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        x, y = 0, 0\n        min_dist = float('inf')\n        for _ in range(n):\n            direction, paces = input().split()\n            paces = int(paces)\n            if direction == 'N':\n                x += 0\n                y += paces\n            elif direction == 'S':\n                x += 0\n                y -= paces\n            elif direction == 'E':\n                x += paces\n                y += 0\n            elif direction == 'W':\n                x -= paces\n                y += 0\n            elif direction == 'NbE':\n                x += paces * math.sin(math.radians(11.25))\n                y += paces * math.cos(math.radians(11.25))\n            elif direction == 'NNE':\n                x += paces * math.sin(math.radians(22.5))\n                y += paces * math.cos(math.radians(22.5))\n            elif direction == 'NEbN':\n                x += paces * math.sin(math.radians(33.75))\n                y += paces * math.cos(math.radians(33.75))\n            elif direction == 'NE':\n                x += paces * math.sin(math.radians(45))\n                y += paces * math.cos(math.radians(45))\n            elif direction == 'NEbE':\n                x += paces * math.sin(math.radians(56.25))\n                y += paces * math.cos(math.radians(56.25))\n            elif direction == 'ENE':\n                x += paces * math.sin(math.radians(67.5))\n                y += paces * math.cos(math.radians(67.5))\n            elif direction == 'EbN':\n                x += paces * math.sin(math.radians(78.75))\n                y += paces * math.cos(math.radians(78.75))\n            elif direction == 'E':\n                x += paces\n                y += 0\n            elif direction == 'EbS':\n                x += paces * math.sin(math.radians(101.25))\n                y += paces * math.cos(math.radians(101.25))\n            elif direction == 'ESE':\n                x += paces * math.sin(math.radians(112.5))\n                y += paces * math.cos(math.radians(112.5))\n            elif direction == 'SEbE':\n                x += paces * math.sin(math.radians(123.75))\n                y += paces * math.cos(math.radians(123.75))\n            elif direction == 'SE':\n                x += paces * math.sin(math.radians(135))\n                y += paces * math.cos(math.radians(135))\n            elif direction == 'SEbS':\n                x += paces * math.sin(math.radians(146.25))\n                y += paces * math.cos(math.radians(146.25))\n            elif direction == 'SSE':\n                x += paces * math.sin(math.radians(157.5))\n                y += paces * math.cos(math.radians(157.5))\n            elif direction == 'SbE':\n                x += paces * math.sin(math.radians(168.75))\n                y += paces * math.cos(math.radians(168.75))\n            elif direction == 'S':\n                x += 0\n                y -= paces\n            elif direction == 'SbW':\n                x += paces * math.sin(math.radians(-168.75))\n                y += paces * math.cos(math.radians(-168.75))\n            elif direction == 'SSW':\n                x += paces * math.sin(math.radians(-157.5))\n                y += paces * math.cos(math.radians(-157.5))\n            elif direction == 'SWbS':\n                x += paces * math.sin(math.radians(-146.25))\n                y += paces * math.cos(math.radians(-146.25))\n            elif direction == 'SW':\n                x += paces * math.sin(math.radians(-135))\n                y += paces * math.cos(math.radians(-135))\n            elif direction == 'SWbW':\n                x += paces * math.sin(math.radians(-123.75))\n                y += paces * math.cos(math.radians(-123.75))\n            elif direction == 'WSW':\n                x += paces * math.sin(math.radians(-112.5))\n                y += paces * math.cos(math.radians(-112.5))\n            elif direction == 'WbS':\n                x += paces * math.sin(math.radians(-101.25))\n                y += paces * math.cos(math.radians(-101.25))\n            elif direction == 'W':\n                x -= paces\n                y += 0\n            elif direction == 'WbN':\n                x += paces * math.sin(math.radians(-78.75))\n                y += paces * math.cos(math.radians(-78.75))\n            elif direction == 'WNW':\n                x += paces * math.sin(math.radians(-67.5))\n                y += paces * math.cos(math.radians(-67.5))\n            elif direction == 'NWbW':\n                x += paces * math.sin(math.radians(-56.25))\n                y += paces * math.cos(math.radians(-56.25))\n            elif direction == 'NW':\n                x += paces * math.sin(math.radians(-45))\n                y += paces * math.cos(math.radians(-45))\n            elif direction == 'NWbN':\n                x += paces * math.sin(math.radians(-33.75))\n                y += paces * math.cos(math.radians(-33.75))\n            elif direction == 'NNW':\n                x += paces * math.sin(math.radians(-22.5))\n                y += paces * math.cos(math.radians(-22.5))\n            elif direction == 'NbW':\n                x += paces * math.sin(math.radians(-11.25))\n                y += paces * math.cos(math.radians(-11.25))\n        d = float(input())\n        x_new = x * math.cos(math.radians(d)) - y * math.sin(math.radians(d))\n        y_new = x * math.sin(math.radians(d)) + y * math.cos(math.radians(d))\n        min_dist = min(min_dist, math.sqrt(x_new**2 + y_new**2))\n        print('{:.2f}'.format(min_dist))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import math\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        x, y = 0, 0\n        min_dist = float('inf')\n        for _ in range(n):\n            direction, paces = input().split()\n            paces = int(paces)\n            if direction == 'N':\n                x += 0\n                y += paces\n            elif direction == 'S':\n                x += 0\n                y -= paces\n            elif direction == 'E':\n                x += paces\n                y += 0\n            elif direction == 'W':\n                x -= paces\n                y += 0\n            elif direction == 'NbE':\n                x += paces * math.sin(math.radians(11.25))\n                y += paces * math.cos(math.radians(11.25))\n            elif direction == 'NNE':\n                x += paces * math.sin(math.radians(22.5))\n                y += paces * math.cos(math.radians(22.5))\n            elif direction == 'NEbN':\n                x += paces * math.sin(math.radians(33.75))\n                y += paces * math.cos(math.radians(33.75))\n            elif direction == 'NE':\n                x += paces * math.sin(math.radians(45))\n                y += paces * math.cos(math.radians(45))\n            elif direction == 'NEbE':\n                x += paces * math.sin(math.radians(56.25))\n                y += paces * math.cos(math.radians(56.25))\n            elif direction == 'ENE':\n                x += paces * math.sin(math.radians(67.5))\n                y += paces * math.cos(math.radians(67.5))\n            elif direction == 'EbN':\n                x += paces * math.sin(math.radians(78.75))\n                y += paces * math.cos(math.radians(78.75))\n            elif direction == 'E':\n                x += paces\n                y += 0\n            elif direction == 'EbS':\n                x += paces * math.sin(math.radians(101.25))\n                y += paces * math.cos(math.radians(101.25))\n            elif direction == 'ESE':\n                x += paces * math.sin(math.radians(112.5))\n                y += paces * math.cos(math.radians(112.5))\n            elif direction == 'SEbE':\n                x += paces * math.sin(math.radians(123.75))\n                y += paces * math.cos(math.radians(123.75))\n            elif direction == 'SE':\n                x += paces * math.sin(math.radians(135))\n                y += paces * math.cos(math.radians(135))\n            elif direction == 'SEbS':\n                x += paces * math.sin(math.radians(146.25))\n                y += paces * math.cos(math.radians(146.25))\n            elif direction == 'SSE':\n                x += paces * math.sin(math.radians(157.5))\n                y += paces * math.cos(math.radians(157.5))\n            elif direction == 'SbE':\n                x += paces * math.sin(math.radians(168.75))\n                y += paces * math.cos(math.radians(168.75))\n            elif direction == 'S':\n                x += 0\n                y -= paces\n            elif direction == 'SbW':\n                x += paces * math.sin(math.radians(-168.75))\n                y += paces * math.cos(math.radians(-168.75))\n            elif direction == 'SSW':\n                x += paces * math.sin(math.radians(-157.5))\n                y += paces * math.cos(math.radians(-157.5))\n            elif direction == 'SWbS':\n                x += paces * math.sin(math.radians(-146.25))\n                y += paces * math.cos(math.radians(-146.25))\n            elif direction == 'SW':\n                x += paces * math.sin(math.radians(-135))\n                y += paces * math.cos(math.radians(-135))\n            elif direction == 'SWbW':\n                x += paces * math.sin(math.radians(-123.75))\n                y += paces * math.cos(math.radians(-123.75))\n            elif direction == 'WSW':\n                x += paces * math.sin(math.radians(-112.5))\n                y += paces * math.cos(math.radians(-112.5))\n            elif direction == 'WbS':\n                x += paces * math.sin(math.radians(-101.25))\n                y += paces * math.cos(math.radians(-101.25))\n            elif direction == 'W':\n                x -= paces\n                y += 0\n            elif direction == 'WbN':\n                x += paces * math.sin(math.radians(-78.75))\n                y += paces * math.cos(math.radians(-78.75))\n            elif direction == 'WNW':\n                x += paces * math.sin(math.radians(-67.5))\n                y += paces * math.cos(math.radians(-67.5))\n            elif direction == 'NWbW':\n                x += paces * math.sin(math.radians(-56.25))\n                y += paces * math.cos(math.radians(-56.25))\n            elif direction == 'NW':\n                x += paces * math.sin(math.radians(-45))\n                y += paces * math.cos(math.radians(-45))\n            elif direction == 'NWbN':\n                x += paces * math.sin(math.radians(-33.75))\n                y += paces * math.cos(math.radians(-33.75))\n            elif direction == 'NNW':\n                x += paces * math.sin(math.radians(-22.5))\n                y += paces * math.cos(math.radians(-22.5))\n            elif direction == 'NbW':\n                x += paces * math.sin(math.radians(-11.25))\n                y += paces * math.cos(math.radians(-11.25))\n            d = math.degrees(math.atan2(y, x))\n            if d < 0:\n                d += 360\n            d -= float(input())\n            if d < 0:\n                d += 360\n            min_dist = min(min_dist, math.sqrt(x**2 + y**2))\n        print('{:.2f}'.format(min_dist))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Godzilla", "final_solution": "from collections import deque\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        L, W = map(int, input().split())\n        grid = [list(input()) for _ in range(W)]\n        mech_units = []\n        godzilla = None\n        for i in range(W):\n            for j in range(L):\n                if grid[i][j] == 'M':\n                    mech_units.append((i, j))\n                elif grid[i][j] == 'G':\n                    godzilla = (i, j)\n        \n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        queue = deque([(godzilla, 0)])\n        visited = {godzilla}\n        destroyed = 0\n        \n        while queue:\n            (x, y), step = queue.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < W and 0 <= ny < L and (nx, ny) not in visited:\n                    if grid[nx][ny] == 'R':\n                        destroyed += 1\n                        grid[nx][ny] = '.'\n                    elif any((nx, ny) == mech_unit for mech_unit in mech_units):\n                        print(destroyed)\n                        break\n                    queue.append(((nx, ny), step + 1))\n                    visited.add((nx, ny))\n            else:\n                continue\n            break\n\nif __name__ == '__main__':\n    main()\n", "initial_solution": "from collections import deque\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        L, W = map(int, input().split())\n        grid = [list(input()) for _ in range(W)]\n        mech_units = []\n        godzilla = None\n        for i in range(W):\n            for j in range(L):\n                if grid[i][j] == 'M':\n                    mech_units.append((i, j))\n                elif grid[i][j] == 'G':\n                    godzilla = (i, j)\n        \n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        queue = deque([(godzilla, 0)])\n        visited = {godzilla}\n        destroyed = 0\n        \n        while queue:\n            (x, y), step = queue.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < W and 0 <= ny < L and (nx, ny) not in visited:\n                    if grid[nx][ny] == 'R':\n                        destroyed += 1\n                        grid[nx][ny] = '.'\n                    elif grid[nx][ny] == 'M':\n                        print(destroyed)\n                        break\n                    queue.append(((nx, ny), step + 1))\n                    visited.add((nx, ny))\n            else:\n                continue\n            break\n\nif __name__ == '__main__':\n    main()\n"}
{"task_id": "Political Development", "final_solution": "import sys\n\ndef solve():\n    n, k = map(int, input().split())\n    S = [input().split() for _ in range(n)]\n    for i in range(n):\n        S[i][0] = int(S[i][0])\n        S[i][1:] = list(map(int, S[i][1:]))\n    max_committee = 0\n    for i in range(n):\n        committee = 1\n        for j in range(n):\n            if i != j:\n                if S[i][0] <= len(set(S[i][1:]) & set(S[j][1:])):\n                    committee += 1\n        max_committee = max(max_committee, committee)\n    print(min(max_committee, k))\n\ndef main():\n    T = 1  # Removed input() here\n    for _ in range(T):\n        solve()\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    N, K = map(int, input().split())\n    graph = [[] for _ in range(N)]\n    for i in range(N):\n        D_i = int(input())\n        for _ in range(D_i):\n            j = int(input())\n            graph[i].append(j)\n            graph[j].append(i)\n\n    max_committee_size = 0\n    for i in range(N):\n        committee_size = 1\n        for j in range(i + 1, N):\n            if i not in graph[j] and len(graph[j]) < K:\n                committee_size += 1\n        max_committee_size = max(max_committee_size, committee_size)\n\n    print(max_committee_size)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Introspective Caching", "final_solution": "import sys\n\ndef main():\n    c, n, a = map(int, input().split())\n    accesses = [int(input()) for _ in range(a)]\n    cache = []\n    reads = 0\n    for obj in accesses:\n        if obj not in cache:\n            if len(cache) == c:\n                cache.pop(0)\n            cache.append(obj)\n            reads += 1\n    print(reads)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    c, n, a = map(int, input().split())\n    accesses = [int(input()) for _ in range(a)]\n    cache = set()\n    reads = 0\n    for obj in accesses:\n        if obj not in cache:\n            if len(cache) == c:\n                cache.pop()\n            cache.add(obj)\n            reads += 1\n    print(reads)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Forever Young", "final_solution": "def main():\n    y, l = map(int, input().split())\n\n    # Initialize the maximum base to 2\n    max_base = 2\n\n    # Iterate from 2 to y (inclusive) to find the maximum base\n    for base in range(2, y + 1):\n        # Convert y to the current base\n        digits = []\n        temp = y\n        while temp > 0:\n            digits.append(str(temp % base))\n            temp //= base\n        digits = ''.join(digits[::-1])\n\n        # Check if the converted decimal contains only decimal digits\n        if all(digit in '0123456789' for digit in digits):\n            # If the converted decimal is at least l, update the maximum base\n            if int(digits, 10) >= l:\n                max_base = base\n\n    print(max_base)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    y, l = map(int, input().split())\n\n    # Initialize the maximum base to 10\n    max_base = 10\n\n    # Iterate from 10 to y (inclusive) to find the maximum base\n    for base in range(10, y + 1):\n        # Convert y to the current base and convert it back to decimal\n        decimal = int(str(y)[::-1], base)[::-1]\n\n        # If the converted decimal is at least l, update the maximum base\n        if decimal >= l:\n            max_base = base\n\n    print(max_base)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Deceptive Directions", "final_solution": "import itertools\n\ndef main():\n    w, h = map(int, input().split())\n    grid = [list(input()) for _ in range(h)]\n    instructions = input()\n\n    # Find the starting position\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == 'S':\n                start_x, start_y = j, i\n                break\n\n    # Initialize the possible treasure positions\n    treasure_positions = set()\n\n    # Generate all possible interpretations of the instructions\n    for instruction in itertools.product('NSEW', repeat=len(instructions)):\n        x, y = start_x, start_y\n        for dir in instruction:\n            if dir == 'N':\n                y -= 1\n            elif dir == 'S':\n                y += 1\n            elif dir == 'E':\n                x += 1\n            elif dir == 'W':\n                x -= 1\n            if 0 <= x < w and 0 <= y < h and grid[y][x] != '#':\n                treasure_positions.add((x, y))\n\n    # Mark the possible treasure positions on the grid\n    for x, y in treasure_positions:\n        grid[y][x] = '!'\n\n    # Print the modified grid\n    for row in grid:\n        print(''.join(row))\n\nif __name__ == '__main__':\n    main()\n", "initial_solution": "def main():\n    w, h = map(int, input().split())\n    grid = [list(input()) for _ in range(h)]\n    instructions = input()\n\n    # Find the starting position\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == 'S':\n                start_x, start_y = j, i\n                break\n\n    # Initialize the possible treasure positions\n    treasure_positions = set()\n\n    # Iterate over all possible interpretations of the instructions\n    for instruction in generate_instructions(instructions):\n        x, y = start_x, start_y\n        for dir in instruction:\n            if dir == 'N':\n                y -= 1\n            elif dir == 'S':\n                y += 1\n            elif dir == 'E':\n                x += 1\n            elif dir == 'W':\n                x -= 1\n            if 0 <= x < w and 0 <= y < h and grid[y][x] != '#':\n                treasure_positions.add((x, y))\n\n    # Mark the possible treasure positions on the grid\n    for x, y in treasure_positions:\n        grid[y][x] = '!'\n\n    # Print the modified grid\n    for row in grid:\n        print(''.join(row))\n\ndef generate_instructions(instructions):\n    if not instructions:\n        return ['']\n    else:\n        instruction = instructions[0]\n        rest = instructions[1:]\n        if instruction == 'N':\n            return [i + 'N' for i in generate_instructions(rest)] + \\\n                   [i + 'S' for i in generate_instructions(rest)] + \\\n                   [i + 'E' for i in generate_instructions(rest)] + \\\n                   [i + 'W' for i in generate_instructions(rest)]\n        elif instruction == 'S':\n            return [i + 'N' for i in generate_instructions(rest)] + \\\n                   [i + 'S' for i in generate_instructions(rest)] + \\\n                   [i + 'E' for i in generate_instructions(rest)] + \\\n                   [i + 'W' for i in generate_instructions(rest)]\n        elif instruction == 'E':\n            return [i + 'N' for i in generate_instructions(rest)] + \\\n                   [i + 'S' for i in generate_instructions(rest)] + \\\n                   [i + 'E' for i in generate_instructions(rest)] + \\\n                   [i + 'W' for i in generate_instructions(rest)]\n        elif instruction == 'W':\n            return [i + 'N' for i in generate_instructions(rest)] + \\\n                   [i + 'S' for i in generate_instructions(rest)] + \\\n                   [i + 'E' for i in generate_instructions(rest)] + \\\n                   [i + 'W' for i in generate_instructions(rest)]\n\nif __name__ == '__main__':\n    main()\n"}
{"task_id": "EvenOdd", "final_solution": "def main():\n    L, R = map(int, input().split())\n    MOD = 10**9 + 7\n    def f(x):\n        iterations = 0\n        while x != 1:\n            if x % 2 == 0:\n                x //= 2\n            else:\n                x += 1\n            iterations += 1\n        return iterations\n\n    S = sum(f(i) for i in range(L, R + 1))\n    print(S % MOD)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    L, R = map(int, input().split())\n    MOD = 10**9 + 7\n    def f(x):\n        iterations = 0\n        while x != 1:\n            if x % 2 == 0:\n                x //= 2\n            else:\n                x += 1\n            iterations += 1\n        return iterations\n\n    S = sum(f(i) for i in range(L, R + 1))\n    print(S % MOD)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Bilateral Projects", "final_solution": "import sys\nfrom collections import defaultdict\n\ndef main():\n    m = int(input())\n    teams = defaultdict(set)\n    for _ in range(m):\n        stockholm, london = map(int, input().split())\n        teams[stockholm].add(london)\n        teams[london].add(stockholm)\n\n    london_invitees = set()\n    stockholm_invitees = set()\n    for stockholm, london_set in teams.items():\n        if len(london_set) == 1:\n            london_invitees.update(london_set)\n        if stockholm == 1009:\n            stockholm_invitees.add(stockholm)\n\n    invitees = london_invitees.union(stockholm_invitees)\n    if 1009 in invitees:\n        invitees.remove(1009)\n        invitees.add(1009)  # Ensure 1009 is always the first invitee\n\n    print(len(invitees))\n    for invitee in sorted(invitees):\n        print(invitee)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    m = int(input())\n    teams = {}\n    for _ in range(m):\n        stockholm, london = map(int, input().split())\n        if stockholm not in teams:\n            teams[stockholm] = set()\n        if london not in teams:\n            teams[london] = set()\n        teams[stockholm].add(london)\n        teams[london].add(stockholm)\n\n    london_invitees = set()\n    stockholm_invitees = set()\n    for stockholm, london_set in teams.items():\n        if len(london_set) == 1:\n            london_invitees.update(london_set)\n        if stockholm == 1009:\n            stockholm_invitees.add(stockholm)\n\n    invitees = london_invitees.union(stockholm_invitees)\n    print(len(invitees))\n    for invitee in invitees:\n        print(invitee)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Typo", "final_solution": "def main():\n    n = int(input())\n    words = [input() for _ in range(n)]\n    typos = []\n\n    for word in words:\n        for i in range(len(word)):\n            new_word = word[:i] + word[i+1:]\n            if new_word in words and new_word != word:\n                typos.append(word)\n                break\n\n    if typos:\n        for typo in typos:\n            print(typo)\n    else:\n        print(\"NO TYPOS\")\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    n = int(input())\n    words = [input() for _ in range(n)]\n    typos = []\n\n    for word in words:\n        for i in range(len(word)):\n            new_word = word[:i] + word[i+1:]\n            if new_word in words and new_word != word:\n                typos.append(word)\n                break\n\n    if typos:\n        for typo in typos:\n            print(typo)\n    else:\n        print(\"NO TYPOS\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Galactic Warlords", "final_solution": "import math\n\ndef main():\n    W, N = map(int, input().split())\n    lines = []\n    for _ in range(N):\n        x1, y1, x2, y2 = map(int, input().split())\n        lines.append((x1, y1, x2, y2))\n\n    # Calculate the number of infinite areas\n    infinite_areas = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            # Calculate the intersection point of two lines\n            x1, y1, x2, y2 = lines[i]\n            x3, y3, x4, y4 = lines[j]\n            denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n            if denominator != 0:\n                px = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / denominator\n                py = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / denominator\n                if not (math.isinf(px) or math.isinf(py)):\n                    infinite_areas += 1\n\n    # Calculate the number of extra lines needed\n    extra_lines = max(0, W - infinite_areas)\n\n    print(extra_lines)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    W, N = map(int, input().split())\n    lines = []\n    for _ in range(N):\n        x1, y1, x2, y2 = map(int, input().split())\n        lines.append((x1, y1, x2, y2))\n\n    # Calculate the number of infinite areas\n    infinite_areas = 0\n    for i in range(N):\n        for j in range(i + 1, N):\n            # Calculate the intersection point of two lines\n            x1, y1, x2, y2 = lines[i]\n            x3, y3, x4, y4 = lines[j]\n            denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4)\n            if denominator != 0:\n                px = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / denominator\n                py = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / denominator\n                if px != float('inf') and py != float('inf'):\n                    infinite_areas += 1\n\n    # Calculate the number of extra lines needed\n    extra_lines = max(0, W - infinite_areas)\n\n    print(extra_lines)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Auto Completion", "final_solution": "from collections import defaultdict\nfrom bisect import bisect_left\n\ndef main():\n    n = int(input())\n    words = [input() for _ in range(n)]\n    words.sort()\n    word_dict = defaultdict(list)\n    for word in words:\n        for i in range(1, len(word) + 1):\n            word_dict[word[:i]].append(word)\n\n    q = int(input())\n    for _ in range(q):\n        seq = input()\n        tabs = seq.count('#')\n        prefix = seq.replace('#', '')\n        if prefix not in word_dict:\n            print(prefix)\n        else:\n            words_with_prefix = word_dict[prefix]\n            idx = bisect_left(words_with_prefix, prefix)\n            if idx == len(words_with_prefix):\n                idx = 0\n            print(words_with_prefix[(idx + tabs - 1) % len(words_with_prefix)])\n\nif __name__ == '__main__':\n    main()\n", "initial_solution": "from collections import defaultdict\nfrom bisect import bisect_left\n\ndef main():\n    n = int(input())\n    words = [input() for _ in range(n)]\n    words.sort()\n    word_dict = defaultdict(list)\n    for word in words:\n        word_dict[word[:1]].append(word)\n\n    q = int(input())\n    for _ in range(q):\n        seq = input()\n        tabs = seq.count('#')\n        prefix = seq.replace('#', '')\n        if prefix not in word_dict:\n            print(prefix)\n        else:\n            words_with_prefix = word_dict[prefix[:1]]\n            idx = bisect_left(words_with_prefix, prefix)\n            if idx == len(words_with_prefix):\n                idx = 0\n            print(words_with_prefix[idx % len(words_with_prefix)])\n\nif __name__ == '__main__':\n    main()\n"}
{"task_id": "Shakespeare, who?", "final_solution": "import sys\n\ndef main():\n    n = int(input())\n    words = [input() for _ in range(n)]\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i == 1 or j == 1:\n                dp[i][j] = 0\n            elif words[i - 1] == words[j - 1]:\n                dp[i][j] = 0\n            else:\n                for k in range(min(len(words[i - 1]), len(words[j - 1])), 0, -1):\n                    if words[i - 1][:k] == words[j - 1][-k:]:\n                        dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + k)\n                        break\n    beauty = 0\n    for i in range(1, n + 1):\n        beauty = max(beauty, max(dp[i]))\n    if beauty == float('inf') or beauty == 0:\n        print(\"Shakespeare, who?\")\n    else:\n        print(beauty)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    n = int(input())\n    words = [input() for _ in range(n)]\n    beauty = 0\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    for i in range(1, n + 1):\n        for j in range(1, n + 1):\n            if i == 1 or j == 1:\n                dp[i][j] = 0\n            elif words[i - 1] == words[j - 1]:\n                dp[i][j] = 0\n            else:\n                for k in range(min(len(words[i - 1]), len(words[j - 1])), 0, -1):\n                    if words[i - 1][:k] == words[j - 1][-k:]:\n                        dp[i][j] = max(dp[i][j], dp[i - 1][j - 1] + k)\n                        break\n    for i in range(1, n + 1):\n        beauty = max(beauty, max(dp[i]))\n    if beauty == float('inf'):\n        print(\"Shakespeare, who?\")\n    else:\n        print(beauty)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Domine", "final_solution": "import sys\n\ndef main():\n    N, K = map(int, input().split())\n    board = [list(map(int, input().split())) for _ in range(N)]\n\n    dp = [[[-float('inf')] * (K + 1) for _ in range(3)] for _ in range(N + 1)]\n\n    dp[0][0][0] = 0\n\n    for i in range(N):\n        for j in range(3):\n            for k in range(K + 1):\n                if k > 0:\n                    if j < 2:\n                        dp[i + 1][j][k] = max(dp[i + 1][j][k], dp[i][j][k - 1] + board[i][j] + board[i][j + 1])\n                    dp[i + 1][j][k] = max(dp[i + 1][j][k], dp[i][j][k - 1] + board[i][j] + board[i - 1][j] if i > 0 else float('-inf'))\n\n    print(max(max(row) for row in dp[-1]))\n\nif __name__ == '__main__':\n    main()\n", "initial_solution": "def main():\n    N, K = map(int, input().split())\n    board = [list(map(int, input().split())) for _ in range(N)]\n\n    # Initialize a 2D array to store the maximum sum for each subproblem\n    dp = [[[-float('inf')] * (K + 1) for _ in range(3)] for _ in range(N)]\n\n    # Base case: no dominoes\n    for i in range(N):\n        dp[i][0][0] = 0\n\n    # Fill up the dp table\n    for i in range(N):\n        for j in range(1, K + 1):\n            for k in range(3):\n                # Try to place a domino horizontally\n                if k < 2:\n                    dp[i][k][j] = max(dp[i][k][j], dp[i - 1][k][j - 1] + board[i][k] + board[i][k + 1])\n                # Try to place a domino vertically\n                if i > 0:\n                    dp[i][k][j] = max(dp[i][k][j], dp[i - 1][k][j - 1] + board[i - 1][k] + board[i][k])\n\n    # The answer is the maximum sum in the last row\n    print(max(max(row) for row in dp[-1]))\n\nif __name__ == '__main__':\n    main()\n"}
{"task_id": "Lights Out", "final_solution": "import sys\nfrom collections import defaultdict, deque\n\ndef main():\n    n, m, l = map(int, input().split())\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    switches = [defaultdict(list) for _ in range(n)]\n    for _ in range(l):\n        line = input().split()\n        room = int(line[0])\n        p = int(line[1])\n        toggles = list(map(int, line[2:]))\n        for toggle in toggles:\n            switches[room][toggle].append(p - 1)\n    dp = [[float('inf')] * (1 << n) for _ in range(n)]\n    dp[1][0] = 0\n    queue = deque([(1, 0)])\n    while queue:\n        room, mask = queue.popleft()\n        for next_room in graph[room]:\n            next_mask = mask\n            if room in switches[next_room]:\n                for toggle in switches[next_room][room]:\n                    next_mask ^= 1 << toggle\n            if dp[next_room][next_mask] > dp[room][mask] + 1:\n                dp[next_room][next_mask] = dp[room][mask] + 1\n                queue.append((next_room, next_mask))\n    ans = float('inf')\n    for mask in range(1 << n):\n        ans = min(ans, dp[0][mask])\n    print(ans + 1)\n\nif __name__ == '__main__':\n    main()\n", "initial_solution": "def main():\n    n, m, l = map(int, input().split())\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    switches = [{} for _ in range(n)]\n    for _ in range(l):\n        room, p = map(int, input().split())\n        toggles = list(map(int, input().split()))\n        switches[room][toggles[0]] = toggles[1:]\n    dp = [[float('inf')] * (1 << n) for _ in range(n)]\n    dp[1][0] = 0\n    for mask in range(1 << n):\n        for room in range(n):\n            if dp[room][mask] == float('inf'):\n                continue\n            for next_room in graph[room]:\n                next_mask = mask\n                if room in switches[next_room]:\n                    for toggle in switches[next_room][room]:\n                        next_mask ^= 1 << toggle\n                dp[next_room][next_mask] = min(dp[next_room][next_mask], dp[room][mask] + 1)\n    ans = float('inf')\n    for mask in range(1 << n):\n        ans = min(ans, dp[0][mask])\n    print(ans + 1)\n\nif __name__ == '__main__':\n    main()\n"}
{"task_id": "Citadel Construction", "final_solution": "import math\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        n = int(input())\n        points = []\n        for _ in range(n):\n            x, y = map(int, input().split())\n            points.append((x, y))\n        \n        max_area = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    area = abs((points[i][0] * (points[j][1] - points[k][1]) + \n                              points[j][0] * (points[k][1] - points[i][1]) + \n                              points[k][0] * (points[i][1] - points[j][1])) / 2.0)\n                    max_area = max(max_area, area)\n        \n        if max_area == int(max_area):\n            print(int(max_area))\n        else:\n            print(\"{:.1f}\".format(max_area))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import math\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        n = int(input())\n        points = []\n        for _ in range(n):\n            x, y = map(int, input().split())\n            points.append((x, y))\n        \n        max_area = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    area = abs((points[i][0] * (points[j][1] - points[k][1]) + \n                              points[j][0] * (points[k][1] - points[i][1]) + \n                              points[k][0] * (points[i][1] - points[j][1])) / 2.0)\n                    max_area = max(max_area, area)\n        \n        if max_area == int(max_area):\n            print(int(max_area))\n        else:\n            print(\"{:.1f}\".format(max_area))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Treasure Hunt", "final_solution": "from collections import deque\n\ndef main():\n    N, M, K = map(int, input().split())\n    grid = [list(input()) for _ in range(N)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    stamina_cost = {'.': 1, 'F': 2, 'M': 3}\n\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'G':\n                goal = (i, j)\n\n    queue = deque([(start, 0, K)])\n    visited = {(start, K)}\n\n    while queue:\n        (x, y), day, stamina = queue.popleft()\n        if (x, y) == goal:\n            print(day)\n            return\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] != '#' and (nx, ny, stamina - stamina_cost[grid[nx][ny]]) not in visited:\n                if stamina >= stamina_cost[grid[nx][ny]]:\n                    queue.append(((nx, ny), day, stamina - stamina_cost[grid[nx][ny]]))\n                else:\n                    queue.append(((nx, ny), day + 1, K - stamina_cost[grid[nx][ny]]))\n                visited.add((nx, ny, stamina - stamina_cost[grid[nx][ny]]))\n\n    print(-1)\n\nif __name__ == '__main__':\n    main()\n", "initial_solution": "from collections import deque\n\ndef main():\n    N, M, K = map(int, input().split())\n    grid = [list(input()) for _ in range(N)]\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    stamina_cost = {'.': 1, 'F': 2, 'M': 3}\n\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'G':\n                goal = (i, j)\n\n    queue = deque([(start, 0, K)])\n    visited = {(start, K)}\n\n    while queue:\n        (x, y), day, stamina = queue.popleft()\n        if (x, y) == goal:\n            print(day)\n            return\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] != '#' and (nx, ny, stamina - stamina_cost[grid[nx][ny]]) not in visited:\n                if stamina >= stamina_cost[grid[nx][ny]]:\n                    queue.append(((nx, ny), day, stamina - stamina_cost[grid[nx][ny]]))\n                else:\n                    queue.append(((nx, ny), day + 1, K - stamina_cost[grid[nx][ny]]))\n                visited.add((nx, ny, stamina - stamina_cost[grid[nx][ny]]))\n\n    print(-1)\n\nif __name__ == '__main__':\n    main()\n"}
{"task_id": "Eco-driving", "final_solution": "import math\nimport heapq\n\ndef main():\n    J, R, D = map(int, input().split())\n    junctions = [list(map(int, input().split())) for _ in range(J)]\n    roads = [list(map(int, input().split())) for _ in range(R)]\n\n    graph = [[] for _ in range(J)]\n    for a, b in roads:\n        graph[a-1].append(b-1)\n        graph[b-1].append(a-1)\n\n    def distance(a, b):\n        return math.sqrt((junctions[a][0] - junctions[b][0])**2 + (junctions[a][1] - junctions[b][1])**2)\n\n    def angle(a, b, c):\n        ab = (junctions[b][0] - junctions[a][0], junctions[b][1] - junctions[a][1])\n        bc = (junctions[c][0] - junctions[b][0], junctions[c][1] - junctions[b][1])\n        dot_product = ab[0]*bc[0] + ab[1]*bc[1]\n        magnitude_product = math.sqrt(ab[0]**2 + ab[1]**2) * math.sqrt(bc[0]**2 + bc[1]**2)\n        return math.acos(dot_product / magnitude_product) * 180 / math.pi\n\n    def dijkstra(start):\n        queue = [(0, start, [start])]\n        visited = set()\n        while queue:\n            dist, node, path = heapq.heappop(queue)\n            if node not in visited:\n                visited.add(node)\n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        new_dist = dist + distance(node, neighbor)\n                        if new_dist <= D:\n                            heapq.heappush(queue, (new_dist, neighbor, path + [neighbor]))\n        return [path for dist, node, path in queue if node == J-1]\n\n    paths = dijkstra(0)\n    if not paths:\n        print(\"Impossible\")\n    else:\n        max_angle = 0\n        for path in paths:\n            for i in range(len(path) - 2):\n                max_angle = max(max_angle, angle(path[i], path[i+1], path[i+2]))\n        print(\"{:.8f}\".format(max_angle))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import math\nimport heapq\n\ndef main():\n    J, R, D = map(int, input().split())\n    junctions = [list(map(int, input().split())) for _ in range(J)]\n    roads = [list(map(int, input().split())) for _ in range(R)]\n\n    graph = [[] for _ in range(J)]\n    for a, b in roads:\n        graph[a-1].append(b-1)\n        graph[b-1].append(a-1)\n\n    def distance(a, b):\n        return math.sqrt((junctions[a][0] - junctions[b][0])**2 + (junctions[a][1] - junctions[b][1])**2)\n\n    def angle(a, b, c):\n        ab = (junctions[b][0] - junctions[a][0], junctions[b][1] - junctions[a][1])\n        bc = (junctions[c][0] - junctions[b][0], junctions[c][1] - junctions[b][1])\n        dot_product = ab[0]*bc[0] + ab[1]*bc[1]\n        magnitude_product = math.sqrt(ab[0]**2 + ab[1]**2) * math.sqrt(bc[0]**2 + bc[1]**2)\n        return math.acos(dot_product / magnitude_product) * 180 / math.pi\n\n    def dijkstra(start):\n        queue = [(0, start, [start])]\n        visited = set()\n        while queue:\n            dist, node, path = heapq.heappop(queue)\n            if node not in visited:\n                visited.add(node)\n                for neighbor in graph[node]:\n                    if neighbor not in visited:\n                        new_dist = dist + distance(node, neighbor)\n                        if new_dist <= D:\n                            heapq.heappush(queue, (new_dist, neighbor, path + [neighbor]))\n\n    max_angle = 0\n    for path in dijkstra(0):\n        for i in range(len(path) - 2):\n            max_angle = max(max_angle, angle(path[i], path[i+1], path[i+2]))\n\n    if max_angle == 0:\n        print(\"Impossible\")\n    else:\n        print(\"{:.8f}\".format(max_angle))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Surveillance", "final_solution": "import math\n\ndef main():\n    n = int(input())\n    points = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        points.append((x, y))\n\n    # Calculate the area of the room\n    area = 0\n    for i in range(n):\n        x1, y1 = points[i]\n        x2, y2 = points[(i + 1) % n]\n        area += x1 * y2 - x2 * y1\n    area = abs(area) / 2\n\n    # Calculate the visible area for each point\n    visible_areas = []\n    for i in range(n):\n        x1, y1 = points[i]\n        x2, y2 = points[(i + 1) % n]\n        x3, y3 = points[(i - 1) % n]\n        visible_area = area\n        for j in range(n):\n            if j != i:\n                x4, y4 = points[j]\n                x5, y5 = points[(j + 1) % n]\n                if (x4 - x1) * (y2 - y1) - (x2 - x1) * (y4 - y1) > 0:\n                    visible_area -= abs((x4 - x1) * (y5 - y1) - (x5 - x1) * (y4 - y1)) / 2\n                if (x4 - x3) * (y2 - y3) - (x2 - x3) * (y4 - y3) > 0:\n                    visible_area -= abs((x4 - x3) * (y5 - y3) - (x5 - x3) * (y4 - y3)) / 2\n        visible_areas.append(visible_area)\n\n    # Calculate the maximum visible area\n    max_visible_area = max(visible_areas)\n\n    print(max_visible_area)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    n = int(input())\n    points = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        points.append((x, y))\n\n    # Calculate the area of the room\n    area = 0\n    for i in range(n):\n        x1, y1 = points[i]\n        x2, y2 = points[(i + 1) % n]\n        area += x1 * y2 - x2 * y1\n    area = abs(area) / 2\n\n    # Calculate the visible area for each point\n    visible_areas = []\n    for i in range(n):\n        x1, y1 = points[i]\n        x2, y2 = points[(i + 1) % n]\n        x3, y3 = points[(i - 1) % n]\n        visible_area = 0\n        for j in range(n):\n            if j != i:\n                x4, y4 = points[j]\n                x5, y5 = points[(j + 1) % n]\n                if (x4 - x1) * (y2 - y1) - (x2 - x1) * (y4 - y1) > 0:\n                    visible_area += abs((x4 - x1) * (y5 - y1) - (x5 - x1) * (y4 - y1)) / 2\n                if (x4 - x3) * (y2 - y3) - (x2 - x3) * (y4 - y3) > 0:\n                    visible_area -= abs((x4 - x3) * (y5 - y3) - (x5 - x3) * (y4 - y3)) / 2\n        visible_areas.append(visible_area)\n\n    # Calculate the maximum visible area\n    max_visible_area = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            visible_area = area\n            for k in range(n):\n                if k != i and k != j:\n                    x4, y4 = points[k]\n                    x5, y5 = points[(k + 1) % n]\n                    if (x4 - points[i][0]) * (points[j][1] - points[i][1]) - (points[j][0] - points[i][0]) * (y4 - points[i][1]) > 0:\n                        visible_area -= abs((x4 - points[i][0]) * (y5 - points[i][1]) - (x5 - points[i][0]) * (y4 - points[i][1])) / 2\n            max_visible_area = max(max_visible_area, visible_area)\n\n    print(max_visible_area)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Classical Counting", "final_solution": "import math\n\ndef main():\n    N, M, K = map(int, input().split())\n    MOD = 10**6 + 7\n\n    # Calculate the number of ways to take exactly K objects\n    ways = math.comb(N*M, K)\n    ways %= MOD\n\n    print(ways)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    N, M, K = map(int, input().split())\n    MOD = 10**6 + 7\n\n    # Calculate the number of ways to take exactly K objects\n    ways = 1\n    for i in range(1, K + 1):\n        ways = (ways * (N - i + 1) * M) % MOD\n        ways = (ways // i) % MOD\n\n    print(ways)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Perfect k-ary Tree", "final_solution": "def main():\n    MOD = 1000000007\n    N, k = map(int, input().split())\n    graph = [[] for _ in range(N + 1)]\n    for _ in range(N - 1):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    dp = [0] * (N + 1)\n\n    def dfs(node, parent):\n        nonlocal dp\n        size = 1\n        for child in graph[node]:\n            if child != parent:\n                size += dfs(child, node)\n        dp[node] = (dp[node] + pow(k, size - 1, MOD)) % MOD\n        return size\n\n    dfs(1, -1)\n    print(sum(dp) % MOD)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    MOD = 1000000007\n    N, k = map(int, input().split())\n    graph = [[] for _ in range(N + 1)]\n    for _ in range(N - 1):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    dp = [0] * (N + 1)\n    dp[0] = 1\n\n    def dfs(node, parent):\n        nonlocal dp\n        size = 1\n        for child in graph[node]:\n            if child != parent:\n                size += dfs(child, node)\n        dp[node] = (dp[node] * pow(k, size - 1, MOD)) % MOD\n        return size\n\n    dfs(1, -1)\n    print(sum(dp) % MOD)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Guess the Numbers", "final_solution": "def main():\n    while True:\n        line = input().split()\n        if line == ['0', '0']:\n            break\n        n = int(line[0])\n        values = list(map(int, line[1:n+1]))\n        result = int(line[n+1])\n        expression = input()\n        \n        def is_valid_assignment(assignment):\n            expr = expression\n            for i, char in enumerate(expression):\n                if char.isalpha():\n                    expr = expr.replace(char, str(assignment[ord(char) - ord('a')]))\n            return eval(expr) == result\n        \n        def backtrack(assignment, index):\n            if index == n:\n                if is_valid_assignment(assignment):\n                    return True\n                return False\n            for value in values:\n                if value not in assignment.values():\n                    assignment[index] = value\n                    if backtrack(assignment, index + 1):\n                        return True\n                    del assignment[index]\n            return False\n        \n        if backtrack({}, 0):\n            print('YES')\n        else:\n            print('NO')\n\nif __name__ == '__main__':\n    main()\n", "initial_solution": "def main():\n    while True:\n        line = input().split()\n        if line == ['0', '0']:\n            break\n        n = int(line[0])\n        values = list(map(int, line[1:n+1]))\n        result = int(line[n+1])\n        expression = input()\n        \n        def is_valid_assignment(assignment):\n            expr = expression\n            for i, char in enumerate(expression):\n                if char.isalpha():\n                    expr = expr.replace(char, str(assignment[ord(char) - ord('a')]))\n            return eval(expr) == result\n        \n        def backtrack(assignment, index):\n            if index == n:\n                if is_valid_assignment(assignment):\n                    print('YES')\n                    return True\n                return False\n            for value in values:\n                if value not in assignment:\n                    assignment[index] = value\n                    if backtrack(assignment, index + 1):\n                        return True\n                    del assignment[index]\n            return False\n        \n        if not backtrack({}, 0):\n            print('NO')\n\nif __name__ == '__main__':\n    main()\n"}
{"task_id": "As Easy as CAB", "final_solution": "from collections import defaultdict, deque\n\ndef main():\n    L, N = input().split()\n    L = ord(L) - 96\n    N = int(N)\n    graph = defaultdict(list)\n    in_degree = [0] * (L + 1)\n    words = []\n    for _ in range(N):\n        word = input()\n        words.append(word)\n    for i in range(N):\n        for j in range(i + 1, N):\n            for c1, c2 in zip(words[i], words[j]):\n                if c1 != c2:\n                    graph[ord(c1) - 97].append(ord(c2) - 97)\n                    in_degree[ord(c2) - 97] += 1\n                    break\n            else:\n                if len(words[i]) > len(words[j]):\n                    graph[L].append(ord(words[i][-1]) - 97)\n                    in_degree[ord(words[i][-1]) - 97] += 1\n\n    queue = deque([i for i in range(L + 1) if in_degree[i] == 0])\n    result = []\n    while queue:\n        node = queue.popleft()\n        result.append(chr(node + 97))\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    if len(result) != L + 1:\n        if len(result) == 0:\n            print(\"IMPOSSIBLE\")\n        else:\n            print(\"AMBIGUOUS\")\n    else:\n        print(\"\".join(sorted(result, reverse=True)))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "from collections import defaultdict, deque\n\ndef main():\n    L, N = input().split()\n    L = ord(L) - 96\n    graph = defaultdict(list)\n    in_degree = [0] * (L + 1)\n    for _ in range(N):\n        s1 = input()\n        for _ in range(N - 1):\n            s2 = input()\n            for c1, c2 in zip(s1, s2):\n                if c1 != c2:\n                    graph[ord(c1) - 96].append(ord(c2) - 96)\n                    in_degree[ord(c2) - 96] += 1\n                    break\n            else:\n                if len(s1) > len(s2):\n                    graph[L].append(ord(s1[-1]) - 96)\n                    in_degree[ord(s1[-1]) - 96] += 1\n\n    queue = deque([i for i in range(L + 1) if in_degree[i] == 0])\n    result = []\n    while queue:\n        node = queue.popleft()\n        result.append(chr(node + 96))\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    if len(result) != L + 1:\n        if len(result) == 0:\n            print(\"IMPOSSIBLE\")\n        else:\n            print(\"AMBIGUOUS\")\n    else:\n        print(\"\".join(result[::-1]))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Catmas Gifts", "final_solution": "import math\n\ndef main():\n    n = int(input())\n\n    # Calculate the expected total number of gifts taken out of the bag\n    expected_gifts = n\n    for i in range(1, n):\n        expected_gifts += 1 / (1 - 1 / i)\n\n    print(\"{:.6f}\".format(expected_gifts))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    n = int(input())\n\n    # Calculate the expected total number of gifts taken out of the bag\n    expected_gifts = 0\n    for i in range(n):\n        expected_gifts += (n / (n - i))\n\n    print(\"{:.6f}\".format(expected_gifts))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Hilbert's Hedge Maze", "final_solution": "import sys\nimport math\n\ndef main():\n    k = int(input())\n    for _ in range(k):\n        n, x1, y1, x2, y2 = map(int, input().split())\n        maze = \"A\"\n        for _ in range(n):\n            maze = maze.replace(\"A\", \"LBFRAFARFBL\").replace(\"B\", \"RAFLBFBLFAR\")\n        maze = maze.replace(\"A\", \"\").replace(\"B\", \"\")\n        directions = {\"F\": (0, 1), \"L\": (0, 0), \"R\": (0, 0)}\n        x, y = 0, 0\n        dx, dy = 0, 1\n        for c in maze:\n            if c == \"F\":\n                x += dx\n                y += dy\n            elif c == \"L\":\n                dx, dy = -dy, dx\n            elif c == \"R\":\n                dx, dy = dy, -dx\n        distance = abs(x2 - x) + abs(y2 - y)\n        print(distance)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    k = int(input())\n    for _ in range(k):\n        n, x1, y1, x2, y2 = map(int, input().split())\n        maze = \"A\"\n        for _ in range(n):\n            maze = maze.replace(\"A\", \"LBFRAFARFBL\").replace(\"B\", \"RAFLBFBLFAR\")\n        maze = maze.replace(\"A\", \"\").replace(\"B\", \"\")\n        directions = {\"F\": (0, 1), \"L\": (0, 0), \"R\": (0, 0)}\n        x, y = 0, 0\n        for c in maze:\n            dx, dy = directions[c]\n            x += dx\n            y += dy\n        dx = abs(x1 - x)\n        dy = abs(y1 - y)\n        print(dx + dy)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Around the track", "final_solution": "import math\n\ndef main():\n    N, M = map(int, input().split())\n    nodes = [list(map(int, input().split())) for _ in range(N)]\n    edges = [list(map(int, input().split())) for _ in range(M)]\n\n    # Create an adjacency list to represent the graph\n    graph = [[] for _ in range(N)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Calculate the degree of each node\n    degrees = [len(neighbors) for neighbors in graph]\n\n    # Find the starting node (a node with an odd degree)\n    for i, degree in enumerate(degrees):\n        if degree % 2 == 1:\n            start = i\n            break\n    else:\n        # If no node with an odd degree is found, set the starting node to 0\n        start = 0\n\n    # Perform an Eulerian circuit traversal\n    path = []\n    stack = [start]\n    while stack:\n        node = stack[-1]\n        if graph[node]:\n            next_node = graph[node].pop()\n            stack.append(next_node)\n        else:\n            path.append(stack.pop())\n\n    # Calculate the total turning required\n    total_turning = 0\n    for i in range(len(path) - 1):\n        x1, y1 = nodes[path[i]]\n        x2, y2 = nodes[path[i + 1]]\n        dx, dy = x2 - x1, y2 - y1\n        angle = math.atan2(dy, dx)\n        total_turning += angle\n\n    # Add the turning required to return to the starting node\n    x1, y1 = nodes[path[-1]]\n    x2, y2 = nodes[path[0]]\n    dx, dy = x2 - x1, y2 - y1\n    angle = math.atan2(dy, dx)\n    total_turning += angle\n\n    # Convert the total turning to radians and print the result\n    print(total_turning % (2 * math.pi))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import math\n\ndef main():\n    N, M = map(int, input().split())\n    nodes = [list(map(int, input().split())) for _ in range(N)]\n    edges = [list(map(int, input().split())) for _ in range(M)]\n\n    # Create an adjacency list to represent the graph\n    graph = [[] for _ in range(N)]\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n\n    # Calculate the degree of each node\n    degrees = [len(neighbors) for neighbors in graph]\n\n    # Find the starting node (a node with an odd degree)\n    start = next(i for i, degree in enumerate(degrees) if degree % 2 == 1)\n\n    # Perform an Eulerian circuit traversal\n    path = []\n    stack = [start]\n    while stack:\n        node = stack[-1]\n        if graph[node]:\n            next_node = graph[node].pop()\n            stack.append(next_node)\n        else:\n            path.append(stack.pop())\n\n    # Calculate the total turning required\n    total_turning = 0\n    for i in range(len(path) - 1):\n        x1, y1 = nodes[path[i]]\n        x2, y2 = nodes[path[i + 1]]\n        dx, dy = x2 - x1, y2 - y1\n        angle = math.atan2(dy, dx)\n        total_turning += angle\n\n    # Add the turning required to return to the starting node\n    x1, y1 = nodes[path[-1]]\n    x2, y2 = nodes[path[0]]\n    dx, dy = x2 - x1, y2 - y1\n    angle = math.atan2(dy, dx)\n    total_turning += angle\n\n    # Convert the total turning to radians and print the result\n    print(total_turning)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "3D Printer", "final_solution": "import math\n\ndef calculate_volume(polyhedra):\n    volume = 0\n    for polyhedron in polyhedra:\n        faces = polyhedron[1:]\n        for face in faces:\n            vertices = face[1:]\n            n = len(vertices) // 3\n            area = 0\n            for i in range(n):\n                j = (i + 1) % n\n                area += (vertices[3 * i + 1] * vertices[3 * j + 2] - vertices[3 * i + 2] * vertices[3 * j + 1])\n            area = abs(area) / 2\n            centroid_x, centroid_y, centroid_z = 0, 0, 0\n            for i in range(n):\n                centroid_x += vertices[3 * i]\n                centroid_y += vertices[3 * i + 1]\n                centroid_z += vertices[3 * i + 2]\n            centroid_x /= n\n            centroid_y /= n\n            centroid_z /= n\n            height = 0\n            for i in range(n):\n                j = (i + 1) % n\n                height += (vertices[3 * i] - centroid_x) * (vertices[3 * j + 1] - centroid_y) - (vertices[3 * i + 1] - centroid_y) * (vertices[3 * j] - centroid_x)\n            height = abs(height) / (2 * area)\n            volume += area * height\n    return volume\n\ndef main():\n    n = int(input())\n    polyhedra = []\n    for _ in range(n):\n        f = int(input())\n        faces = []\n        for _ in range(f):\n            v = int(input())\n            vertices = list(map(float, input().split()))\n            faces.append([v] + vertices)\n        polyhedra.append([f] + faces)\n    volume = calculate_volume(polyhedra)\n    print(\"{:.2f}\".format(volume))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import math\n\ndef calculate_volume(polyhedra):\n    volume = 0\n    for polyhedron in polyhedra:\n        faces = polyhedron[1:]\n        for face in faces:\n            vertices = face[1:]\n            n = len(vertices) // 3\n            area = 0\n            for i in range(n):\n                j = (i + 1) % n\n                area += (vertices[3 * i + 1] * vertices[3 * j + 2] - vertices[3 * i + 2] * vertices[3 * j + 1])\n            area = abs(area) / 2\n            centroid_x, centroid_y, centroid_z = 0, 0, 0\n            for i in range(n):\n                centroid_x += vertices[3 * i]\n                centroid_y += vertices[3 * i + 1]\n                centroid_z += vertices[3 * i + 2]\n            centroid_x /= n\n            centroid_y /= n\n            centroid_z /= n\n            height = 0\n            for i in range(n):\n                j = (i + 1) % n\n                height += (vertices[3 * i] - centroid_x) * (vertices[3 * j + 1] - centroid_y) - (vertices[3 * i + 1] - centroid_y) * (vertices[3 * j] - centroid_x)\n            height = abs(height) / (2 * area)\n            volume += area * height\n    return volume\n\ndef main():\n    n = int(input())\n    polyhedra = []\n    for _ in range(n):\n        f = int(input())\n        faces = []\n        for _ in range(f):\n            v = int(input())\n            vertices = list(map(float, input().split()))\n            faces.append([v] + vertices)\n        polyhedra.append([f] + faces)\n    volume = calculate_volume(polyhedra)\n    print(\"{:.2f}\".format(volume))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Saskatchewan", "final_solution": "def main():\n    # Read the number of vertices\n    n = int(input())\n\n    # Initialize the area\n    area = 0\n\n    # Read the vertices\n    x, y = map(int, input().split())\n    for _ in range(n - 1):\n        nx, ny = map(int, input().split())\n        area += (nx - x) * (ny - y)\n        x, y = nx, ny\n\n    # Add the last edge\n    nx, ny = 0, 0\n    area += (nx - x) * (ny - y)\n\n    # Calculate the number of sections\n    sections = abs(area) // 2\n\n    # Calculate the number of sections fully contained within the province\n    sections //= 1000000\n\n    print(sections)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    # Read the number of vertices\n    n = int(input())\n\n    # Initialize the area\n    area = 0\n\n    # Read the vertices\n    x, y = map(int, input().split())\n    for _ in range(n - 1):\n        nx, ny = map(int, input().split())\n        area += (nx - x) * (ny + y)\n        x, y = nx, ny\n\n    # Calculate the number of sections\n    sections = abs(area) // 2\n\n    print(sections)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Eccentric Excursion", "final_solution": "from collections import defaultdict, deque\n\ndef main():\n    n, k = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    if k == 0:\n        print(-1)\n        return\n\n    visited = [False] * (n + 1)\n    path = []\n\n    def dfs(node, k):\n        nonlocal path\n        visited[node] = True\n        path.append(node)\n        if k == 0:\n            return True\n        for neighbor in sorted(graph[node]):\n            if not visited[neighbor]:\n                if dfs(neighbor, k - 1):\n                    return True\n        path.pop()\n        visited[node] = False\n        return False\n\n    for i in range(1, n + 1):\n        if dfs(i, k):\n            print(' '.join(map(str, path)))\n            return\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "from collections import defaultdict, deque\n\ndef main():\n    n, k = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    if k == 0:\n        print(-1)\n        return\n\n    visited = [False] * (n + 1)\n    path = []\n\n    def dfs(node, k):\n        nonlocal path\n        visited[node] = True\n        path.append(node)\n        if k == 0:\n            return True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                if dfs(neighbor, k - 1):\n                    return True\n        path.pop()\n        visited[node] = False\n        return False\n\n    for i in range(1, n + 1):\n        if dfs(i, k):\n            print(' '.join(map(str, path)))\n            return\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Div 2, Mul 2, Mul 3", "final_solution": "def main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        nums = list(map(int, input().split()))\n        nums.sort()\n        if nums[0] != 1:\n            print('NO')\n            continue\n        flag = True\n        for i in range(1, n):\n            if nums[i] % nums[i-1] not in [2, 3] and nums[i-1] * 2 != nums[i] and nums[i-1] * 3 != nums[i] and nums[i] != nums[i-1] // 2:\n                flag = False\n                break\n        if flag:\n            print('YES')\n            print(' '.join(map(str, nums)))\n        else:\n            print('NO')\n\nif __name__ == '__main__':\n    main()\n", "initial_solution": "def main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        nums = list(map(int, input().split()))\n        nums.sort()\n        if nums[0] != 1:\n            print('NO')\n            continue\n        for i in range(1, n):\n            if nums[i] % nums[i-1] not in [2, 3] and nums[i-1] * 2 != nums[i]:\n                print('NO')\n                break\n        else:\n            print('YES')\n            print(' '.join(map(str, nums)))\n\nif __name__ == '__main__':\n    main()\n"}
{"task_id": "Blacksmith Training", "final_solution": "import sys\n\ndef main():\n    n = int(input())\n    plans = []\n    for _ in range(n):\n        e, m, p, d = map(int, input().split())\n        plans.append((e, m, p, d))\n\n    plans.sort(key=lambda x: x[0])\n\n    dp = [float('inf')] * 301\n    dp[0] = 0\n\n    for e, m, p, d in plans:\n        for j in range(m, e - 1, -1):\n            dp[j] = min(dp[j], dp[e] + p + (j - e) * d)\n\n    print(min(dp[300], dp[299], dp[298]))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    n = int(input())\n    plans = []\n    for _ in range(n):\n        e, m, p, d = map(int, input().split())\n        plans.append((e, m, p, d))\n\n    plans.sort(key=lambda x: x[0])\n\n    dp = [float('inf')] * 301\n    dp[0] = 0\n\n    for i in range(n):\n        e, m, p, d = plans[i]\n        for j in range(m, e - 1, -1):\n            dp[j] = min(dp[j], dp[e] + p + (j - e) * d)\n\n    print(dp[300])\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Magical Distances", "final_solution": "import heapq\n\ndef main():\n    n, m = map(int, input().split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b, w = map(int, input().split())\n        graph[a].append((b, w))\n        graph[b].append((a, w))\n\n    q = int(input())\n    for _ in range(q):\n        s, t = map(int, input().split())\n        dist = [float('inf')] * (n + 1)\n        dist[s] = 0\n        pq = [(0, s)]\n        while pq:\n            d, u = heapq.heappop(pq)\n            if d > dist[u]:\n                continue\n            for v, w in graph[u]:\n                nd = d | w\n                if nd < dist[v]:\n                    dist[v] = nd\n                    heapq.heappush(pq, (nd, v))\n        print(dist[t])\n\nif __name__ == '__main__':\n    main()\n", "initial_solution": "import heapq\n\ndef main():\n    n, m = map(int, input().split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b, w = map(int, input().split())\n        graph[a].append((b, w))\n        graph[b].append((a, w))\n\n    q = int(input())\n    for _ in range(q):\n        s, t = map(int, input().split())\n        dist = [float('inf')] * (n + 1)\n        dist[s] = 0\n        pq = [(0, s)]\n        while pq:\n            d, u = heapq.heappop(pq)\n            if d > dist[u]:\n                continue\n            for v, w in graph[u]:\n                nd = d | w\n                if nd < dist[v]:\n                    dist[v] = nd\n                    heapq.heappush(pq, (nd, v))\n        print(dist[t])\n\nif __name__ == '__main__':\n    main()\n"}
{"task_id": "Pipes", "final_solution": "import sys\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        r, c = map(int, input().split())\n        grid = [input() for _ in range(2 * r + 1)]\n        dp = [[float('inf')] * (c * 2) for _ in range(r * 2)]\n        dp[0][1] = 0\n        for i in range(r * 2):\n            for j in range(c * 2):\n                if grid[i][j] == '#':\n                    continue\n                if i > 0 and grid[i - 1][j] != '#' and grid[i - 1][j] != ' ':\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j] + int(grid[i - 1][j]))\n                if j > 0 and grid[i][j - 1] != '#' and grid[i][j - 1] != ' ':\n                    dp[i][j] = min(dp[i][j], dp[i][j - 1] + int(grid[i][j - 1]))\n        print(dp[-1][-2] if dp[-1][-2] != float('inf') else -1)\n\nif __name__ == '__main__':\n    main()\n", "initial_solution": "import sys\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        r, c = map(int, input().split())\n        grid = [input() for _ in range(2 * r + 1)]\n        dp = [[float('inf')] * (c * 2) for _ in range(r * 2)]\n        dp[0][1] = 0\n        for i in range(r * 2):\n            for j in range(c * 2):\n                if grid[i][j] != '#':\n                    continue\n                if i > 0:\n                    dp[i][j] = min(dp[i][j], dp[i - 1][j] + int(grid[i - 1][j]))\n                if j > 0:\n                    dp[i][j] = min(dp[i][j], dp[i][j - 1] + int(grid[i][j - 1]))\n        print(dp[-1][-2])\n\nif __name__ == '__main__':\n    main()\n"}
{"task_id": "Special Cycle", "final_solution": "import sys\n\ndef main():\n    n, m, k = map(int, input().split())\n    graph = [[] for _ in range(n + 1)]\n    special_edges = set()\n    for i in range(m):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n        if i < k:\n            special_edges.add((a, b))\n            special_edges.add((b, a))\n\n    def dfs(node, parent, visited, path):\n        visited.add(node)\n        path.append(node)\n        for neighbor in graph[node]:\n            if neighbor == parent:\n                continue\n            if neighbor in visited:\n                if (node, neighbor) in special_edges or (neighbor, node) in special_edges:\n                    return path\n                else:\n                    continue\n            result = dfs(neighbor, node, visited, path)\n            if result:\n                return result\n        path.pop()\n        return None\n\n    for i in range(1, n + 1):\n        visited = set()\n        path = []\n        result = dfs(i, -1, visited, path)\n        if result:\n            print(len(result))\n            for node in result:\n                print(node)\n            return\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    n, m, k = map(int, input().split())\n    graph = [[] for _ in range(n + 1)]\n    special_edges = set()\n    for i in range(m):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n        if i < k:\n            special_edges.add((a, b))\n            special_edges.add((b, a))\n\n    def dfs(node, parent, visited, path):\n        visited.add(node)\n        path.append(node)\n        for neighbor in graph[node]:\n            if neighbor == parent:\n                continue\n            if neighbor in visited:\n                if (node, neighbor) in special_edges or (neighbor, node) in special_edges:\n                    return path\n                else:\n                    continue\n            result = dfs(neighbor, node, visited, path)\n            if result:\n                return result\n        path.pop()\n        return None\n\n    for i in range(1, n + 1):\n        visited = set()\n        path = []\n        result = dfs(i, -1, visited, path)\n        if result:\n            print(len(result))\n            for node in result:\n                print(node)\n            return\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Barking Up The Wrong Tree", "final_solution": "import math\n\ndef distance(x1, y1, x2, y2):\n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\ndef main():\n    n, m = map(int, input().split())\n    toys = []\n    for _ in range(n):\n        toys.append(list(map(int, input().split())))\n    trees = []\n    for _ in range(m):\n        trees.append(list(map(int, input().split())))\n    \n    leash_length = 0\n    x, y = 0, 0\n    for toy in toys:\n        min_dist = float('inf')\n        for tx, ty in [(x, y)] + trees:\n            dx, dy = toy[0] - tx, toy[1] - ty\n            dist = distance(tx, ty, toy[0], toy[1])\n            if dist < min_dist:\n                min_dist = dist\n                nx, ny = tx, ty\n        leash_length += min_dist\n        x, y = nx, ny\n    \n    print(format(leash_length, \".2f\"))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import math\n\ndef distance(x1, y1, x2, y2):\n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\ndef main():\n    n, m = map(int, input().split())\n    toys = []\n    for _ in range(n):\n        toys.append(list(map(int, input().split())))\n    trees = []\n    for _ in range(m):\n        trees.append(list(map(int, input().split())))\n    \n    leash_length = 0\n    x, y = 0, 0\n    for toy in toys:\n        leash_length += distance(x, y, toy[0], toy[1])\n        x, y = toy[0], toy[1]\n    \n    print(format(leash_length, \".2f\"))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "The Wire Ghost", "final_solution": "def main():\n    L, n = map(int, input().split())\n    events = []\n    for _ in range(n):\n        x, d = input().split()\n        x = int(x)\n        if d == 'C':\n            events.append((x, -1))\n        else:\n            events.append((x, 1))\n    events.sort()\n    stack = []\n    for x, d in events:\n        while stack and stack[-1][0] < x:\n            if stack[-1][1] != -d:\n                print('GHOST')\n                return\n            stack.pop()\n        stack.append((x, d))\n    print('SAFE')\n\nif __name__ == '__main__':\n    main()\n", "initial_solution": "def main():\n    L, n = map(int, input().split())\n    events = []\n    for _ in range(n):\n        x, d = input().split()\n        x = int(x)\n        if d == 'C':\n            events.append((x, -1))\n        else:\n            events.append((x, 1))\n    events.sort()\n    stack = []\n    for x, d in events:\n        while stack and stack[-1][0] >= x:\n            stack.pop()\n        if stack and stack[-1][1] != d:\n            print('GHOST')\n            return\n        stack.append((x, d))\n    print('SAFE')\n\nif __name__ == '__main__':\n    main()\n"}
