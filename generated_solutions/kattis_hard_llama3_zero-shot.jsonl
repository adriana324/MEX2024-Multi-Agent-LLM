{"task_id": "Bribe", "final_solution": "import sys\n\ndef main():\n    test_cases = int(input())\n    for _ in range(test_cases):\n        n, c, m = map(int, input().split())\n        henchmen = []\n        for _ in range(n):\n            b, p = map(int, input().split())\n            henchmen.append((b, p / 100))\n        henchmen.sort()\n        dp = [[[0.0 for _ in range(m + 1)] for _ in range(c + 1)] for _ in range(n + 1)]\n        dp[0][0][0] = 1.0\n        for i in range(1, n + 1):\n            for j in range(min(i, c) + 1):\n                for k in range(m + 1):\n                    dp[i][j][k] = dp[i - 1][j][k]\n                    if j > 0 and k >= henchmen[i - 1][0]:\n                        b, p = henchmen[i - 1]\n                        dp[i][j][k] = max(dp[i][j][k], dp[i - 1][j - 1][k - b] * p + dp[i - 1][j][k] * (1 - p))\n        print(\"%.6f\" % dp[n][c][m])\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import sys\n\ndef main():\n    test_cases = int(input())\n    for _ in range(test_cases):\n        n, c, m = map(int, input().split())\n        henchmen = []\n        for _ in range(n):\n            b, p = map(int, input().split())\n            henchmen.append((b, p / 100))\n        henchmen.sort(reverse=True)\n        dp = [[0.0] * (m + 1) for _ in range(c + 1)]\n        dp[0][0] = 1.0\n        for i in range(1, c + 1):\n            for j in range(1, m + 1):\n                dp[i][j] = dp[i][j - 1]\n                for k, (b, p) in enumerate(henchmen):\n                    if b <= j:\n                        dp[i][j] = max(dp[i][j], dp[i - 1][j - b] * p)\n        print(\"%.6f\" % dp[c][m])\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Classrooms", "final_solution": "import heapq\n\ndef main():\n    lines = [line.rstrip() for line in iter(input, '')]\n    n, k = map(int, lines[0].split())\n    activities = []\n    for line in lines[1:]:\n        s, f = map(int, line.split())\n        activities.append((s, f))\n    activities.sort()\n\n    pq = []\n    ans = 0\n    for s, f in activities:\n        while pq and pq[0] <= s:\n            heapq.heappop(pq)\n        if len(pq) < k:\n            heapq.heappush(pq, f)\n            ans += 1\n        else:\n            if pq[0] > f:\n                heapq.heappop(pq)\n                heapq.heappush(pq, f)\n            else:\n                continue\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import heapq\n\ndef main():\n    n, k = map(int, input().split())\n    activities = []\n    for _ in range(n):\n        s, f = map(int, input().split())\n        activities.append((s, f))\n    activities.sort()\n\n    pq = []\n    ans = 0\n    for s, f in activities:\n        while pq and pq[0] <= s:\n            heapq.heappop(pq)\n        if len(pq) < k:\n            heapq.heappush(pq, f)\n            ans += 1\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "You Be the Judge!", "final_solution": "import re\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(n**0.5) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef main():\n    result = 1\n    for line in iter(input, ''):\n        nums = re.split('\\s+', line)\n        nums = [num for num in nums if num]  # remove empty strings\n        if len(nums) != 3:\n            result = 0\n            break\n        try:\n            n, p1, p2 = map(int, nums)\n        except ValueError:\n            result = 0\n            break\n        if not (n % 2 == 0 and 4 <= n <= 10**9 and is_prime(p1) and is_prime(p2) and n == p1 + p2):\n            result = 0\n            break\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import re\n\ndef is_prime(n):\n    if n <= 1:\n        return False\n    if n == 2:\n        return True\n    if n % 2 == 0:\n        return False\n    max_divisor = int(n**0.5) + 1\n    for d in range(3, max_divisor, 2):\n        if n % d == 0:\n            return False\n    return True\n\ndef main():\n    input_str = input()\n    lines = input_str.splitlines()\n    if len(lines) != 1:\n        print(0)\n        return\n    line = lines[0]\n    nums = re.split('\\s+', line)\n    if len(nums) != 3:\n        print(0)\n        return\n    try:\n        n, p1, p2 = map(int, nums)\n    except ValueError:\n        print(0)\n        return\n    if not (n % 2 == 0 and 4 <= n <= 10**9 and is_prime(p1) and is_prime(p2) and n == p1 + p2):\n        print(0)\n        return\n    print(1)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Tour Guide", "final_solution": "import math\n\ndef distance(x1, y1, x2, y2):\n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\ndef time_to_bus(x, y, v, a, my_v):\n    dx = -x\n    dy = -y\n    d = math.sqrt(dx ** 2 + dy ** 2)\n    v_rel = v * math.sin(a)\n    if v_rel >= my_v:\n        return float('inf')\n    else:\n        return math.ceil(d / (my_v - v_rel))\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        my_v = float(input())\n        max_time = 0\n        for _ in range(n):\n            x, y, v, a = map(float, input().split())\n            a = math.radians(a)\n            t = time_to_bus(x, y, v, a, my_v)\n            max_time = max(max_time, t)\n        print(math.ceil(max_time))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import math\n\ndef distance(x1, y1, x2, y2):\n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\ndef time_to_bus(x, y, v, a, my_v):\n    dx = x\n    dy = y\n    if a != 0:\n        dx = x / math.cos(a)\n        dy = y / math.sin(a)\n    d = math.sqrt(dx ** 2 + dy ** 2)\n    return math.ceil(d / (my_v - v))\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        my_v = float(input())\n        max_time = 0\n        for _ in range(n):\n            x, y, v, a = map(float, input().split())\n            a = math.radians(a)\n            t = time_to_bus(x, y, v, a, my_v)\n            max_time = max(max_time, t)\n        print(max_time)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Hot Spot", "final_solution": "from collections import deque\n\ndef hot_spot():\n    board = [input() for _ in range(4)]\n    for i in range(4):\n        for j in range(4):\n            if board[i][j] == 'R':\n                red_x, red_y = i, j\n                break\n\n    queue = deque([(red_x, red_y, 0)])  # (x, y, jumps)\n    visited = {(red_x, red_y)}\n\n    while queue:\n        x, y, jumps = queue.popleft()\n        if x == 0 and y == 0:\n            return jumps\n\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < 4 and 0 <= ny < 4:\n                if (nx, ny) not in visited:\n                    if board[nx][ny] == '.':\n                        queue.append((nx, ny, jumps + 1))\n                        visited.add((nx, ny))\n                    else:\n                        for ddx, ddy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                            nnx, nny = nx + ddx, ny + ddy\n                            if 0 <= nnx < 4 and 0 <= nny < 4 and board[nnx][nny] == '.':\n                                queue.append((nnx, nny, jumps + 1))\n                                visited.add((nnx, nny))\n                            nnx, nny = nx - ddx, ny - ddy\n                            if 0 <= nnx < 4 and 0 <= nny < 4 and board[nnx][nny] == '.':\n                                queue.append((nnx, nny, jumps + 1))\n                                visited.add((nnx, nny))\n\n    return -1  # if no solution is found\n\ndef main():\n    print(hot_spot())\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "from collections import deque\n\ndef hot_spot():\n    board = [input() for _ in range(4)]\n    for i in range(4):\n        for j in range(4):\n            if board[i][j] == 'R':\n                red_x, red_y = i, j\n                break\n\n    queue = deque([(red_x, red_y, 0)])  # (x, y, jumps)\n    visited = {(red_x, red_y)}\n\n    while queue:\n        x, y, jumps = queue.popleft()\n        if x == 0 and y == 0:\n            return jumps\n\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < 4 and 0 <= ny < 4:\n                if (nx, ny) not in visited:\n                    if board[nx][ny] == '.':\n                        queue.append((nx, ny, jumps + 1))\n                        visited.add((nx, ny))\n                    elif board[nx][ny] != 'B':\n                        for ddx, ddy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                            nnx, nny = nx + ddx, ny + ddy\n                            if 0 <= nnx < 4 and 0 <= nny < 4 and board[nnx][nny] == '.':\n                                queue.append((nnx, nny, jumps + 1))\n                                visited.add((nnx, nny))\n                            for dddx, dddy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n                                nnnx, nnny = nnx + dddx, nny + dddy\n                                if 0 <= nnnx < 4 and 0 <= nnny < 4 and board[nnnx][nnny] == '.':\n                                    queue.append((nnnx, nnny, jumps + 1))\n                                    visited.add((nnnx, nnny))\n\ndef main():\n    print(hot_spot())\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Treasure Map", "final_solution": "import math\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        x, y = 0, 0\n        min_dist = float('inf')\n        directions = {\n            'N': (0, 1),\n            'NbE': (math.sin(math.radians(11.25)), math.cos(math.radians(11.25))),\n            'NNE': (math.sin(math.radians(22.5)), math.cos(math.radians(22.5))),\n            'NEbN': (math.sin(math.radians(33.75)), math.cos(math.radians(33.75))),\n            'NE': (math.sin(math.radians(45)), math.cos(math.radians(45))),\n            'NEbE': (math.sin(math.radians(56.25)), math.cos(math.radians(56.25))),\n            'ENE': (math.sin(math.radians(67.5)), math.cos(math.radians(67.5))),\n            'EbN': (math.sin(math.radians(78.75)), math.cos(math.radians(78.75))),\n            'E': (1, 0),\n            'EbS': (math.sin(math.radians(101.25)), math.cos(math.radians(101.25))),\n            'ESE': (math.sin(math.radians(112.5)), math.cos(math.radians(112.5))),\n            'SEbE': (math.sin(math.radians(123.75)), math.cos(math.radians(123.75))),\n            'SE': (math.sin(math.radians(135)), math.cos(math.radians(135))),\n            'SEbS': (math.sin(math.radians(146.25)), math.cos(math.radians(146.25))),\n            'SSE': (math.sin(math.radians(157.5)), math.cos(math.radians(157.5))),\n            'SbE': (math.sin(math.radians(168.75)), math.cos(math.radians(168.75))),\n            'S': (0, -1),\n            'SbW': (math.sin(math.radians(-168.75)), math.cos(math.radians(-168.75))),\n            'SSW': (math.sin(math.radians(-157.5)), math.cos(math.radians(-157.5))),\n            'SWbS': (math.sin(math.radians(-146.25)), math.cos(math.radians(-146.25))),\n            'SW': (math.sin(math.radians(-135)), math.cos(math.radians(-135))),\n            'SWbW': (math.sin(math.radians(-123.75)), math.cos(math.radians(-123.75))),\n            'WSW': (math.sin(math.radians(-112.5)), math.cos(math.radians(-112.5))),\n            'WbS': (math.sin(math.radians(-101.25)), math.cos(math.radians(-101.25))),\n            'W': (-1, 0),\n            'WbN': (math.sin(math.radians(-78.75)), math.cos(math.radians(-78.75))),\n            'WNW': (math.sin(math.radians(-67.5)), math.cos(math.radians(-67.5))),\n            'NWbW': (math.sin(math.radians(-56.25)), math.cos(math.radians(-56.25))),\n            'NW': (math.sin(math.radians(-45)), math.cos(math.radians(-45))),\n            'NWbN': (math.sin(math.radians(-33.75)), math.cos(math.radians(-33.75))),\n            'NNW': (math.sin(math.radians(-22.5)), math.cos(math.radians(-22.5))),\n            'NbW': (math.sin(math.radians(-11.25)), math.cos(math.radians(-11.25))),\n        }\n        for _ in range(n):\n            direction = input()\n            paces = int(input())\n            dx, dy = directions[direction]\n            angle = float(input())\n            x_true = dx * math.cos(math.radians(angle)) - dy * math.sin(math.radians(angle))\n            y_true = dx * math.sin(math.radians(angle)) + dy * math.cos(math.radians(angle))\n            x += paces * x_true\n            y += paces * y_true\n            dist = math.sqrt(x**2 + y**2)\n            min_dist = min(min_dist, dist)\n        print(\"{:.2f}\".format(min_dist))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import math\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        x, y = 0, 0\n        min_dist = float('inf')\n        for _ in range(n):\n            direction, paces = input().split()\n            paces = int(paces)\n            if direction == 'N':\n                x += 0\n                y += paces\n            elif direction == 'NbE':\n                x += paces * math.sin(math.radians(11.25))\n                y += paces * math.cos(math.radians(11.25))\n            elif direction == 'NNE':\n                x += paces * math.sin(math.radians(22.5))\n                y += paces * math.cos(math.radians(22.5))\n            elif direction == 'NEbN':\n                x += paces * math.sin(math.radians(33.75))\n                y += paces * math.cos(math.radians(33.75))\n            elif direction == 'NE':\n                x += paces * math.sin(math.radians(45))\n                y += paces * math.cos(math.radians(45))\n            elif direction == 'NEbE':\n                x += paces * math.sin(math.radians(56.25))\n                y += paces * math.cos(math.radians(56.25))\n            elif direction == 'ENE':\n                x += paces * math.sin(math.radians(67.5))\n                y += paces * math.cos(math.radians(67.5))\n            elif direction == 'EbN':\n                x += paces * math.sin(math.radians(78.75))\n                y += paces * math.cos(math.radians(78.75))\n            elif direction == 'E':\n                x += paces\n                y += 0\n            elif direction == 'EbS':\n                x += paces * math.sin(math.radians(101.25))\n                y += paces * math.cos(math.radians(101.25))\n            elif direction == 'ESE':\n                x += paces * math.sin(math.radians(112.5))\n                y += paces * math.cos(math.radians(112.5))\n            elif direction == 'SEbE':\n                x += paces * math.sin(math.radians(123.75))\n                y += paces * math.cos(math.radians(123.75))\n            elif direction == 'SE':\n                x += paces * math.sin(math.radians(135))\n                y += paces * math.cos(math.radians(135))\n            elif direction == 'SEbS':\n                x += paces * math.sin(math.radians(146.25))\n                y += paces * math.cos(math.radians(146.25))\n            elif direction == 'SSE':\n                x += paces * math.sin(math.radians(157.5))\n                y += paces * math.cos(math.radians(157.5))\n            elif direction == 'SbE':\n                x += paces * math.sin(math.radians(168.75))\n                y += paces * math.cos(math.radians(168.75))\n            elif direction == 'S':\n                x += 0\n                y -= paces\n            elif direction == 'SbW':\n                x += paces * math.sin(math.radians(-168.75))\n                y += paces * math.cos(math.radians(-168.75))\n            elif direction == 'SSW':\n                x += paces * math.sin(math.radians(-157.5))\n                y += paces * math.cos(math.radians(-157.5))\n            elif direction == 'SWbS':\n                x += paces * math.sin(math.radians(-146.25))\n                y += paces * math.cos(math.radians(-146.25))\n            elif direction == 'SW':\n                x += paces * math.sin(math.radians(-135))\n                y += paces * math.cos(math.radians(-135))\n            elif direction == 'SWbW':\n                x += paces * math.sin(math.radians(-123.75))\n                y += paces * math.cos(math.radians(-123.75))\n            elif direction == 'WSW':\n                x += paces * math.sin(math.radians(-112.5))\n                y += paces * math.cos(math.radians(-112.5))\n            elif direction == 'WbS':\n                x += paces * math.sin(math.radians(-101.25))\n                y += paces * math.cos(math.radians(-101.25))\n            elif direction == 'W':\n                x -= paces\n                y += 0\n            elif direction == 'WbN':\n                x += paces * math.sin(math.radians(-78.75))\n                y += paces * math.cos(math.radians(-78.75))\n            elif direction == 'WNW':\n                x += paces * math.sin(math.radians(-67.5))\n                y += paces * math.cos(math.radians(-67.5))\n            elif direction == 'NWbW':\n                x += paces * math.sin(math.radians(-56.25))\n                y += paces * math.cos(math.radians(-56.25))\n            elif direction == 'NW':\n                x += paces * math.sin(math.radians(-45))\n                y += paces * math.cos(math.radians(-45))\n            elif direction == 'NWbN':\n                x += paces * math.sin(math.radians(-33.75))\n                y += paces * math.cos(math.radians(-33.75))\n            elif direction == 'NNW':\n                x += paces * math.sin(math.radians(-22.5))\n                y += paces * math.cos(math.radians(-22.5))\n            elif direction == 'NbW':\n                x += paces * math.sin(math.radians(-11.25))\n                y += paces * math.cos(math.radians(-11.25))\n            dist = math.sqrt(x**2 + y**2)\n            min_dist = min(min_dist, dist)\n        angle = float(input())\n        x_true = x * math.cos(math.radians(angle)) - y * math.sin(math.radians(angle))\n        y_true = x * math.sin(math.radians(angle)) + y * math.cos(math.radians(angle))\n        print(\"{:.2f}\".format(math.sqrt(x_true**2 + y_true**2)))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Godzilla", "final_solution": "from collections import deque\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        L, W = map(int, input().split())\n        grid = [list(input()) for _ in range(L)]\n        mech_units = []\n        godzilla = None\n        for i in range(L):\n            for j in range(W):\n                if grid[i][j] == 'M':\n                    mech_units.append((i, j))\n                elif grid[i][j] == 'G':\n                    godzilla = (i, j)\n        \n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        q = deque([(godzilla, 0)])\n        visited = {godzilla}\n        destroyed = 0\n        \n        while q:\n            (x, y), step = q.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < L and 0 <= ny < W and (nx, ny) not in visited:\n                    if grid[nx][ny] == 'R':\n                        destroyed += 1\n                        grid[nx][ny] = '.'\n                    elif grid[nx][ny] == '.':\n                        q.append(((nx, ny), step + 1))\n                    visited.add((nx, ny))\n        \n        for x, y in mech_units:\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < L and 0 <= ny < W and grid[nx][ny] == 'G':\n                    print(destroyed)\n                    break\n            else:\n                continue\n            break\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "from collections import deque\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        L, W = map(int, input().split())\n        grid = [list(input()) for _ in range(W)]\n        mech_units = []\n        godzilla = None\n        for i in range(W):\n            for j in range(L):\n                if grid[i][j] == 'M':\n                    mech_units.append((i, j))\n                elif grid[i][j] == 'G':\n                    godzilla = (i, j)\n        \n        directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n        q = deque([(godzilla, 0)])\n        visited = {godzilla}\n        destroyed = 0\n        \n        while q:\n            (x, y), step = q.popleft()\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < W and 0 <= ny < L and (nx, ny) not in visited:\n                    if grid[nx][ny] == 'R':\n                        destroyed += 1\n                        grid[nx][ny] = '.'\n                    elif grid[nx][ny] == '.':\n                        q.append(((nx, ny), step + 1))\n                    visited.add((nx, ny))\n        \n        for x, y in mech_units:\n            for dx, dy in directions:\n                nx, ny = x + dx, y + dy\n                if 0 <= nx < W and 0 <= ny < L and grid[nx][ny] == 'G':\n                    print(destroyed)\n                    break\n            else:\n                continue\n            break\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Political Development", "final_solution": "from collections import defaultdict\n\ndef main():\n    N, K = map(int, input().split())\n    graph = defaultdict(list)\n    for i in range(N):\n        D_i, *disagree = map(int, input().split())\n        for j in disagree:\n            graph[i].append(j)\n            graph[j].append(i)\n\n    max_committee = 0\n    visited = [False] * N\n\n    def dfs(node, size):\n        nonlocal max_committee\n        max_committee = max(max_committee, size)\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, size + 1)\n\n    for i in range(N):\n        if not visited[i]:\n            dfs(i, 1)\n\n    print(min(max_committee, K))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "from collections import defaultdict\n\ndef main():\n    N, K = map(int, input().split())\n    graph = defaultdict(list)\n    for i in range(N):\n        D_i, *disagree = map(int, input().split())\n        for j in disagree:\n            graph[i].append(j)\n            graph[j].append(i)\n\n    max_committee = 0\n    visited = [False] * N\n\n    def dfs(node, size):\n        nonlocal max_committee\n        max_committee = max(max_committee, size)\n        visited[node] = True\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                dfs(neighbor, size + 1)\n\n    for i in range(N):\n        if not visited[i]:\n            dfs(i, 1)\n\n    print(min(max_committee, K))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Introspective Caching", "final_solution": "from collections import OrderedDict\n\ndef main():\n    c, n, a = map(int, input().split())\n    accesses = [int(input()) for _ in range(a)]\n    cache = OrderedDict()\n    reads = 0\n\n    for obj in accesses:\n        if obj not in cache:\n            if len(cache) == c:\n                cache.popitem(last=False)\n            cache[obj] = None\n            reads += 1\n\n    print(reads)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "from collections import OrderedDict\n\ndef main():\n    c, n, a = map(int, input().split())\n    accesses = [int(input()) for _ in range(a)]\n    cache = OrderedDict()\n    reads = 0\n\n    for obj in accesses:\n        if obj not in cache:\n            if len(cache) == c:\n                cache.popitem(last=False)\n            cache[obj] = None\n            reads += 1\n\n    print(reads)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Forever Young", "final_solution": "def main():\n    y, l = map(int, input().split())\n    max_base = 2\n    for base in range(10, y + 1):\n        num_str = convert_base(y, base)\n        if all(digit in '0123456789' for digit in num_str) and int(num_str, base) >= l:\n            max_base = base\n    print(max_base)\n\n\ndef convert_base(n, base):\n    convertString = \"0123456789\"\n    if n < base:\n        return convertString[n]\n    else:\n        return convert_base(n // base, base) + convertString[n % base]\n\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    y, l = map(int, input().split())\n    max_base = 9\n    for base in range(9, 1, -1):\n        num_str = convert_base(y, base)\n        if all(digit in '0123456789' for digit in num_str) and int(num_str, base) >= l:\n            max_base = base\n            break\n    print(max_base)\n\n\ndef convert_base(n, base):\n    convertString = \"0123456789\"\n    if n < base:\n        return convertString[n]\n    else:\n        return convert_base(n // base, base) + convertString[n % base]\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Deceptive Directions", "final_solution": "import itertools\n\ndef main():\n    w, h = map(int, input().split())\n    grid = [list(input()) for _ in range(h)]\n    instructions = input()\n\n    # Find the starting point\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == 'S':\n                start_x, start_y = j, i\n                break\n\n    # Define the movements for each direction\n    movements = {'N': (-1, 0), 'S': (1, 0), 'E': (0, 1), 'W': (0, -1)}\n\n    # Initialize the possible treasure locations\n    treasure_locations = set()\n\n    # Try all possible interpretations of the instructions\n    for directions in itertools.product('NSEW', repeat=len(instructions)):\n        x, y = start_x, start_y\n        for direction in directions:\n            dx, dy = movements[direction]\n            x += dx\n            y += dy\n            if 0 <= x < w and 0 <= y < h and grid[y][x] == '.':\n                treasure_locations.add((x, y))\n\n    # Mark the possible treasure locations on the grid\n    for x, y in treasure_locations:\n        grid[y][x] = '!'\n\n    # Print the grid\n    for row in grid:\n        print(''.join(row))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    w, h = map(int, input().split())\n    grid = [list(input()) for _ in range(h)]\n    instructions = input()\n\n    # Find the starting point\n    for i in range(h):\n        for j in range(w):\n            if grid[i][j] == 'S':\n                start_x, start_y = j, i\n                break\n\n    # Define the movements for each direction\n    movements = {'N': (-1, 0), 'S': (1, 0), 'E': (0, 1), 'W': (0, -1)}\n\n    # Initialize the possible treasure locations\n    treasure_locations = set()\n\n    # Try all possible interpretations of the instructions\n    for i in range(4 ** len(instructions)):\n        x, y = start_x, start_y\n        for j in range(len(instructions)):\n            direction = instructions[j]\n            new_direction = list('NSEW')\n            new_direction.remove(direction)\n            new_direction = new_direction[i % 4 ** (len(instructions) - j) // 4 ** (len(instructions) - j - 1)]\n            dx, dy = movements[new_direction]\n            x += dx\n            y += dy\n            if 0 <= x < w and 0 <= y < h and grid[y][x] == '.':\n                treasure_locations.add((x, y))\n\n    # Mark the possible treasure locations on the grid\n    for x, y in treasure_locations:\n        grid[y][x] = '!'\n\n    # Print the grid\n    for row in grid:\n        print(''.join(row))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "EvenOdd", "final_solution": "def f(X):\n    iterations = 0\n    while X != 1:\n        if X % 2 == 0:\n            X //= 2\n        else:\n            X += 1\n        iterations += 1\n    return iterations\n\ndef main():\n    L, R = map(int, input().split())\n    S = sum(f(X) for X in range(L, R + 1))\n    print(S % (10**9 + 7))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def f(X):\n    iterations = 0\n    while X != 1:\n        if X % 2 == 0:\n            X //= 2\n        else:\n            X += 1\n        iterations += 1\n    return iterations\n\ndef main():\n    L, R = map(int, input().split())\n    S = sum(f(X) for X in range(L, R + 1))\n    print(S % (10**9 + 7))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Bilateral Projects", "final_solution": "from collections import defaultdict\n\ndef main():\n    m = int(input())\n    teams = defaultdict(list)\n    stockholm = set()\n    london = set()\n\n    for _ in range(m):\n        stockholm_id, london_id = map(int, input().split())\n        teams[london_id].append(stockholm_id)\n        stockholm.add(stockholm_id)\n        london.add(london_id)\n\n    london_invitees = set()\n    stockholm_invitees = set()\n\n    for london_id, stockholm_ids in teams.items():\n        if len(stockholm_ids) > 1:\n            london_invitees.add(london_id)\n        else:\n            if 1009 in stockholm_ids:\n                stockholm_invitees.add(1009)\n            else:\n                stockholm_invitees.add(stockholm_ids[0])\n\n    k = len(london_invitees) + len(stockholm_invitees)\n    print(k)\n\n    for london_id in london_invitees:\n        print(london_id)\n    for stockholm_id in stockholm_invitees:\n        print(stockholm_id)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "from collections import defaultdict\n\ndef main():\n    m = int(input())\n    teams = defaultdict(list)\n    stockholm = set()\n    london = set()\n\n    for _ in range(m):\n        stockholm_id, london_id = map(int, input().split())\n        teams[london_id].append(stockholm_id)\n        stockholm.add(stockholm_id)\n        london.add(london_id)\n\n    london_invitees = set()\n    stockholm_invitees = set()\n\n    for london_id, stockholm_ids in teams.items():\n        if len(stockholm_ids) > 1:\n            london_invitees.add(london_id)\n        else:\n            stockholm_invitees.add(stockholm_ids[0])\n\n    if 1009 in stockholm_invitees:\n        stockholm_invitees.remove(1009)\n        london_invitees.add(2011)\n\n    k = len(london_invitees) + len(stockholm_invitees)\n    print(k)\n\n    for london_id in london_invitees:\n        print(london_id)\n    for stockholm_id in stockholm_invitees:\n        print(stockholm_id)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Typo", "final_solution": "def main():\n    n = int(input())\n    dictionary = [input() for _ in range(n)]\n    typos = []\n\n    for word in dictionary:\n        for i in range(len(word)):\n            new_word = word[:i] + word[i+1:]\n            if new_word in dictionary and new_word != word:\n                typos.append(word)\n                break\n\n    if typos:\n        for typo in typos:\n            print(typo)\n    else:\n        print(\"NO TYPOS\")\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    n = int(input())\n    dictionary = [input() for _ in range(n)]\n    typos = []\n\n    for word in dictionary:\n        for i in range(len(word)):\n            new_word = word[:i] + word[i+1:]\n            if new_word in dictionary and new_word != word:\n                typos.append(word)\n                break\n\n    if typos:\n        for typo in typos:\n            print(typo)\n    else:\n        print(\"NO TYPOS\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Galactic Warlords", "final_solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef find_gcd(lines):\n    x1, y1, x2, y2 = lines[0]\n    dx, dy = x2 - x1, y2 - y1\n    g = gcd(dx, dy)\n    dx, dy = dx // g, dy // g\n    for x1, y1, x2, y2 in lines[1:]:\n        dx2, dy2 = x2 - x1, y2 - y1\n        g = gcd(dx2, dy2)\n        dx2, dy2 = dx2 // g, dy2 // g\n        if (dx, dy) != (dx2, dy2) and (dx, dy) != (-dx2, -dy2):\n            return False\n    return True\n\ndef main():\n    W, N = map(int, input().split())\n    lines = [list(map(int, input().split())) for _ in range(N)]\n    if find_gcd(lines):\n        print(0)\n    else:\n        print(1)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef find_gcd(lines):\n    x1, y1, x2, y2 = lines[0]\n    dx, dy = x2 - x1, y2 - y1\n    g = gcd(dx, dy)\n    dx, dy = dx // g, dy // g\n    for x1, y1, x2, y2 in lines[1:]:\n        dx2, dy2 = x2 - x1, y2 - y1\n        g = gcd(dx2, dy2)\n        dx2, dy2 = dx2 // g, dy2 // g\n        if (dx, dy) != (dx2, dy2) and (dx, dy) != (-dx2, -dy2):\n            return False\n    return True\n\ndef main():\n    W, N = map(int, input().split())\n    lines = [list(map(int, input().split())) for _ in range(N)]\n    if find_gcd(lines):\n        print(0)\n    else:\n        print(1)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Auto Completion", "final_solution": "import sys\nfrom collections import defaultdict\n\ndef main():\n    n = int(input())\n    dictionary = [input() for _ in range(n)]\n    dictionary.sort()\n\n    prefix_dict = defaultdict(list)\n    for word in dictionary:\n        for i in range(1, len(word) + 1):\n            prefix_dict[word[:i]].append(word)\n\n    q = int(input())\n    for _ in range(q):\n        sequence = input()\n        text = ''\n        i = 0\n        tab_count = 0\n        while i < len(sequence):\n            if sequence[i] == '#':\n                if text:  # Check if text is not empty\n                    prefix = text\n                    words = prefix_dict[prefix]\n                    if words:\n                        text = words[tab_count % len(words)]\n                        tab_count += 1\n                    else:\n                        tab_count = 0  # Reset tab count if no words match the prefix\n                i += 1\n            else:\n                if tab_count > 0:  # Reset tab count when user starts typing again\n                    tab_count = 0\n                prefix = text + sequence[i]  # Append the new letter to the prefix\n                words = prefix_dict[prefix]\n                if words:\n                    text += sequence[i]\n                    tab_count = 0  # Reset tab count\n                else:\n                    text += sequence[i]\n                i += 1\n        print(text)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import sys\nfrom collections import defaultdict\n\ndef main():\n    n = int(input())\n    dictionary = [input() for _ in range(n)]\n    dictionary.sort()\n\n    prefix_dict = defaultdict(list)\n    for word in dictionary:\n        for i in range(1, len(word) + 1):\n            prefix_dict[word[:i]].append(word)\n\n    q = int(input())\n    for _ in range(q):\n        sequence = input()\n        text = ''\n        i = 0\n        while i < len(sequence):\n            if sequence[i] == '#':\n                prefix = text\n                words = prefix_dict[prefix]\n                if words:\n                    text = words[(len(words) - 1) % len(words)]\n                i += 1\n            else:\n                text += sequence[i]\n                i += 1\n        print(text)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Shakespeare, who?", "final_solution": "import itertools\n\ndef main():\n    n = int(input())\n    beautiful_words = [input() for _ in range(n)]\n\n    max_beauty = 0\n    for permutation in itertools.permutations(beautiful_words):\n        beauty = 0\n        for i in range(n - 1):\n            for k in range(min(len(permutation[i]), len(permutation[i + 1])), 0, -1):\n                if permutation[i][-k:] == permutation[i +1][:k]:\n                    beauty += k\n                    break\n            if permutation[i] == permutation[i + 1]:\n                beauty = -1\n                break\n        if beauty > max_beauty:\n            max_beauty = beauty\n\n    if max_beauty == -1:\n        print(\"Shakespeare, who?\")\n    else:\n        print(max_beauty)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    n = int(input())\n    beautiful_words = [input() for _ in range(n)]\n\n    max_beauty = 0\n    for i in range(n):\n        for j in range(n):\n            if i != j:\n                beauty = 0\n                for k in range(min(len(beautiful_words[i]), len(beautiful_words[j])), 0, -1):\n                    if beautiful_words[i][-k:] == beautiful_words[j][:k]:\n                        beauty = k\n                        break\n                max_beauty = max(max_beauty, beauty)\n\n    if max_beauty == 0:\n        print(\"Shakespeare, who?\")\n    else:\n        print(max_beauty * n)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Domine", "final_solution": "import heapq\n\ndef main():\n    N, K = map(int, input().split())\n    board = [list(map(int, input().split())) for _ in range(N)]\n\n    # Sort the columns of the board in descending order\n    for row in board:\n        row.sort(reverse=True)\n\n    # Initialize the maximum sum\n    max_sum = 0\n\n    # Try to place the dominoes in a greedy manner\n    for i in range(N - 1):\n        for j in range(2):\n            if K > 0:\n                max_sum += board[i][j] + board[i + 1][j]\n                K -= 1\n            if K > 0 and j < 2:\n                max_sum += board[i][j] + board[i][j + 1]\n                K -= 1\n\n    print(max_sum)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import heapq\n\ndef main():\n    N, K = map(int, input().split())\n    board = [list(map(int, input().split())) for _ in range(N)]\n    \n    # Calculate the sum of each possible domino\n    domino_sums = []\n    for i in range(N):\n        for j in range(2):\n            domino_sums.append(board[i][j] + board[i][j+1])\n        if i < N - 1:\n            for j in range(3):\n                domino_sums.append(board[i][j] + board[i+1][j])\n    \n    # Use a heap to get the K largest sums\n    heapq.heapify(domino_sums)\n    max_sum = sum(-heapq.heappop(domino_sums) for _ in range(K))\n    \n    print(max_sum)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Lights Out", "final_solution": "from collections import deque\n\ndef main():\n    n, m, l = map(int, input().split())\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    switches = [set() for _ in range(n)]\n    for _ in range(l):\n        line = input().split()\n        room, p = int(line[0]), int(line[1])\n        toggles = set(map(int, line[2:]))\n        switches[room].update(toggles)\n    queue = deque([(1, 0, 0)])  # (room, steps, mask)\n    visited = {(1, 0)}\n    while queue:\n        room, steps, mask = queue.popleft()\n        if room == 0:\n            print(steps + 1)\n            return\n        for next_room in graph[room]:\n            next_mask = mask\n            for toggle in switches[room]:\n                if (1 << toggle) & mask:\n                    next_mask ^= 1 << toggle\n            if (next_room, next_mask) not in visited:\n                visited.add((next_room, next_mask))\n                queue.append((next_room, steps + 1, next_mask))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "from collections import deque\n\ndef main():\n    n, m, l = map(int, input().split())\n    graph = [[] for _ in range(n)]\n    for _ in range(m):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n    switches = [set() for _ in range(n)]\n    for _ in range(l):\n        room, p = map(int, input().split())\n        toggles = set(map(int, input().split()[1:]))\n        switches[room].update(toggles)\n    queue = deque([(1, 0, 0)])  # (room, steps, mask)\n    visited = {(1, 0)}\n    while queue:\n        room, steps, mask = queue.popleft()\n        if room == 0:\n            print(steps + 1)\n            return\n        for next_room in graph[room]:\n            next_mask = mask\n            for toggle in switches[room]:\n                if toggle & mask:\n                    next_mask ^= 1 << toggle\n            if (next_room, next_mask) not in visited:\n                visited.add((next_room, next_mask))\n                queue.append((next_room, steps + 1, next_mask))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Citadel Construction", "final_solution": "import math\n\ndef calculate_area(points):\n    n = len(points)\n    area = 0\n    for i in range(n):\n        j = (i + 1) % n\n        area += points[i][0] * points[j][1]\n        area -= points[j][0] * points[i][1]\n    return abs(area) / 2.0\n\ndef orientation(p, q, r):\n    x1, y1 = p\n    x2, y2 = q\n    x3, y3 = r\n    val = (y2 - y1) * (x3 - x2) - (x2 - x1) * (y3 - y2)\n    if val == 0:\n        return 0  # Collinear\n    elif val > 0:\n        return 1  # Clockwise\n    else:\n        return 2  # Counterclockwise\n\ndef convex_hull(points):\n    n = len(points)\n    hull = []\n    start = min(points, key=lambda x: (x[1], x[0]))\n    points.remove(start)\n    points.sort(key=lambda p: math.atan2(p[1] - start[1], p[0] - start[0]))\n    points.insert(0, start)\n    hull.append(points[0])\n    hull.append(points[1])\n    for i in range(2, n):\n        while len(hull) > 1 and orientation(hull[-2], hull[-1], points[i]) != 2:\n            hull.pop()\n        hull.append(points[i])\n    return hull\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        points = []\n        for _ in range(n):\n            x, y = map(int, input().split())\n            points.append((x, y))\n        \n        hull = convex_hull(points)\n        area = calculate_area(hull)\n        if area == int(area):\n            print(int(area))\n        else:\n            print(\"{:.1f}\".format(area))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import math\n\ndef calculate_area(p1, p2, p3):\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    return abs((x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)) / 2.0)\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        points = []\n        for _ in range(n):\n            x, y = map(int, input().split())\n            points.append((x, y))\n        \n        max_area = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    area = calculate_area(points[i], points[j], points[k])\n                    max_area = max(max_area, area)\n        \n        if max_area == int(max_area):\n            print(int(max_area))\n        else:\n            print(\"{:.1f}\".format(max_area))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Treasure Hunt", "final_solution": "from collections import deque\n\ndef main():\n    N, M, K = map(int, input().split())\n    grid = [input() for _ in range(N)]\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'G':\n                goal = (i, j)\n\n    queue = deque([(start, K, 0)])\n    visited = {(start, K)}\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    stamina_cost = {'.': 1, 'F': 2, 'M': 3, 'S': 0, 'G': 0}\n\n    while queue:\n        (x, y), stamina, days = queue.popleft()\n        if (x, y) == goal:\n            print(days + 1)\n            return\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] != '#':\n                n_stamina = stamina - stamina_cost[grid[nx][ny]]\n                if n_stamina >= 0:\n                    if ((nx, ny), n_stamina) not in visited:\n                        queue.append(((nx, ny), n_stamina, days))\n                        visited.add(((nx, ny), n_stamina))\n                else:\n                    if ((nx, ny), K) not in visited:\n                        queue.append(((nx, ny), K, days + 1))\n                        visited.add(((nx, ny), K))\n\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "from collections import deque\n\ndef main():\n    N, M, K = map(int, input().split())\n    grid = [input() for _ in range(N)]\n    for i in range(N):\n        for j in range(M):\n            if grid[i][j] == 'S':\n                start = (i, j)\n            elif grid[i][j] == 'G':\n                goal = (i, j)\n\n    queue = deque([(start, K, 0)])\n    visited = {(start, K)}\n    directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    stamina_cost = {'.': 1, 'F': 2, 'M': 3}\n\n    while queue:\n        (x, y), stamina, days = queue.popleft()\n        if (x, y) == goal:\n            print(days + 1)\n            return\n        for dx, dy in directions:\n            nx, ny = x + dx, y + dy\n            if 0 <= nx < N and 0 <= ny < M and grid[nx][ny] != '#':\n                n_stamina = stamina - stamina_cost[grid[nx][ny]]\n                if n_stamina >= 0 and ((nx, ny), n_stamina) not in visited:\n                    queue.append(((nx, ny), n_stamina, days + (n_stamina == 0)))\n                    visited.add(((nx, ny), n_stamina))\n\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Eco-driving", "final_solution": "import heapq\nimport math\n\ndef main():\n    J, R, D = map(int, input().split())\n    junctions = [list(map(int, input().split())) for _ in range(J)]\n    roads = [list(map(int, input().split())) for _ in range(R)]\n\n    graph = [[] for _ in range(J)]\n    for a, b in roads:\n        graph[a-1].append(b-1)\n\n    queue = [(0, 0, 0, 0, -1)]  # (distance, max_angle, prev_junction, current_junction, prev_prev_junction)\n    visited = set()\n    min_max_angle = float('inf')\n    min_distance = float('inf')\n    while queue:\n        distance, max_angle, prev_prev_junction, prev_junction, current_junction = heapq.heappop(queue)\n        if current_junction == J-1:\n            if distance <= D:\n                min_max_angle = min(min_max_angle, max_angle)\n                min_distance = min(min_distance, distance)\n            continue\n        if (current_junction, distance) in visited:\n            continue\n        visited.add((current_junction, distance))\n        for next_junction in graph[current_junction]:\n            if next_junction == prev_junction or next_junction == prev_prev_junction:\n                continue\n            next_distance = distance + math.hypot(junctions[next_junction][0]-junctions[current_junction][0], junctions[next_junction][1]-junctions[current_junction][1])\n            if next_distance > D:\n                continue\n            if prev_junction != -1:\n                v1 = (junctions[current_junction][0]-junctions[prev_junction][0], junctions[current_junction][1]-junctions[prev_junction][1])\n                v2 = (junctions[next_junction][0]-junctions[current_junction][0], junctions[next_junction][1]-junctions[current_junction][1])\n                magnitude1 = math.hypot(v1[0], v1[1])\n                magnitude2 = math.hypot(v2[0], v2[1])\n                if magnitude1 == 0 or magnitude2 == 0:\n                    next_max_angle = max_angle\n                else:\n                    dot_product = v1[0]*v2[0] + v1[1]*v2[1]\n                    cos_angle = dot_product / (magnitude1 * magnitude2)\n                    angle = math.acos(cos_angle)\n                    next_max_angle = max(max_angle, math.degrees(angle))\n            else:\n                next_max_angle = max_angle\n            heapq.heappush(queue, (next_distance, next_max_angle, current_junction, next_junction, prev_junction))\n\n    if min_distance > D:\n        print(\"Impossible\")\n    else:\n        print(f\"{min_max_angle:.8f}\")\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import heapq\nimport math\n\ndef main():\n    J, R, D = map(int, input().split())\n    junctions = [list(map(int, input().split())) for _ in range(J)]\n    roads = [list(map(int, input().split())) for _ in range(R)]\n\n    graph = [[] for _ in range(J)]\n    for a, b in roads:\n        graph[a-1].append(b-1)\n\n    queue = [(0, 0, 0, 0)]  # (distance, max_angle, prev_junction, current_junction)\n    visited = set()\n    while queue:\n        distance, max_angle, prev_junction, current_junction = heapq.heappop(queue)\n        if current_junction == J-1:\n            print(f\"{max_angle:.8f}\")\n            return\n        if (current_junction, distance) in visited:\n            continue\n        visited.add((current_junction, distance))\n        for next_junction in graph[current_junction]:\n            if next_junction == prev_junction:\n                continue\n            next_distance = distance + math.hypot(junctions[next_junction][0]-junctions[current_junction][0], junctions[next_junction][1]-junctions[current_junction][1])\n            if next_distance > D:\n                continue\n            next_max_angle = max(max_angle, calculate_angle(junctions[prev_junction], junctions[current_junction], junctions[next_junction]))\n            heapq.heappush(queue, (next_distance, next_max_angle, current_junction, next_junction))\n\n    print(\"Impossible\")\n\ndef calculate_angle(p1, p2, p3):\n    x1, y1 = p1\n    x2, y2 = p2\n    x3, y3 = p3\n    v1 = (x2-x1, y2-y1)\n    v2 = (x3-x2, y3-y2)\n    dot_product = v1[0]*v2[0] + v1[1]*v2[1]\n    magnitude1 = math.hypot(v1[0], v1[1])\n    magnitude2 = math.hypot(v2[0], v2[1])\n    cos_angle = dot_product / (magnitude1 * magnitude2)\n    angle = math.acos(cos_angle)\n    return math.degrees(angle)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Surveillance", "final_solution": "import math\n\ndef main():\n    n = int(input())\n    points = [list(map(int, input().split())) for _ in range(n)]\n\n    polygon_area = polygon_area_shoelace(points)\n    visible_points = []\n    for i in range(n):\n        p1 = points[i]\n        p2 = points[(i + 1) % n]\n        if is_visible_line(p1, p2, points):\n            visible_points.append(p1)\n            visible_points.append(p2)\n\n    visible_points = list(set(visible_points))\n    visible_area = polygon_area_shoelace(visible_points)\n\n    print(visible_area)\n\ndef polygon_area_shoelace(points):\n    n = len(points)\n    area = 0\n    for i in range(n):\n        p1 = points[i]\n        p2 = points[(i + 1) % n]\n        area += p1[0] * p2[1] - p2[0] * p1[1]\n    return abs(area) / 2\n\ndef is_visible_line(p1, p2, points):\n    for i in range(len(points)):\n        p3 = points[i]\n        p4 = points[(i + 1) % len(points)]\n        if p3 != p1 and p3 != p2 and p4 != p1 and p4 != p2:\n            if intersect(p1, p2, p3, p4):\n                return False\n    return True\n\ndef intersect(p1, p2, p3, p4):\n    v1 = (p2[0] - p1[0], p2[1] - p1[1])\n    v2 = (p3[0] - p1[0], p3[1] - p1[1])\n    v3 = (p4[0] - p1[0], p4[1] - p1[1])\n    cross_product1 = v1[0] * v2[1] - v1[1] * v2[0]\n    cross_product2 = v1[0] * v3[1] - v1[1] * v3[0]\n    if cross_product1 * cross_product2 < 0:\n        return True\n    return False\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import math\nfrom shapely.geometry import Polygon\n\ndef main():\n    n = int(input())\n    points = [tuple(map(int, input().split())) for _ in range(n)]\n    poly = Polygon(points)\n\n    visible_area = 0\n    for x in range(-1000, 1001):\n        for y in range(-1000, 1001):\n            point = (x, y)\n            if poly.contains(point):\n                visible = True\n                for i in range(n):\n                    p1 = points[i]\n                    p2 = points[(i + 1) % n]\n                    if not is_visible(point, p1, p2):\n                        visible = False\n                        break\n                if visible:\n                    visible_area += 1\n\n    print(visible_area)\n\ndef is_visible(point, p1, p2):\n    v1 = (p2[0] - p1[0], p2[1] - p1[1])\n    v2 = (point[0] - p1[0], point[1] - p1[1])\n    cross_product = v1[0] * v2[1] - v1[1] * v2[0]\n    if cross_product == 0:\n        return True\n    return False\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Classical Counting", "final_solution": "import math\n\ndef comb(n, k, MOD):\n    if k > n - k:\n        k = n - k\n    result = 1\n    for i in range(1, k + 1):\n        result = (result * (n - i + 1)) % MOD\n        result = (result // i) % MOD\n    return result\n\ndef multinomial_coefficient(counts, MOD):\n    result = comb(sum(counts), len(counts), MOD)\n    for count in counts:\n        result = (result // comb(count, count, MOD)) % MOD\n    return result\n\ndef main():\n    N, M, K = map(int, input().split())\n    MOD = 10**6 + 7\n\n    # Calculate the number of ways using multinomial coefficients\n    ways = 0\n    for counts in generate_counts(N, M, K):\n        ways = (ways + multinomial_coefficient(counts, MOD)) % MOD\n\n    print(ways)\n\ndef generate_counts(N, M, K):\n    if N == 0:\n        if K == 0:\n            yield []\n        else:\n            return\n    else:\n        for k in range(min(K, M) + 1):\n            for counts in generate_counts(N - 1, M, K - k):\n                yield [k] + counts\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import math\n\ndef main():\n    N, M, K = map(int, input().split())\n    MOD = 10**6 + 7\n\n    # Calculate the number of ways using combinatorics\n    ways = math.comb(N*M, K)\n\n    # Take the result modulo 10^6 + 7\n    result = ways % MOD\n\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n\nHere's an explanation of the code:\n\n1. We import the `math` module, which provides the `comb` function for calculating combinations.\n2. In the `main` function, we read the input values `N`, `M`, and `K` using the `input` function and split them into separate variables using the `map` function.\n3. We define the modulo value `MOD` as 10^6 + 7.\n4. We calculate the number of ways to take exactly `K` objects from `N` objects with `M` copies each using the formula for combinations: `N*M` choose `K`. We use the `math.comb` function to calculate this value.\n5. We take the result modulo `MOD` to ensure the output is within the required range.\n6. Finally, we print the result using the `print` function.\n\nNote that the `math.comb` function is only available in Python 3.8 and later. If you're using an earlier version of Python, you can use the following alternative implementation:\ndef comb(n, k):\n    if k > n - k:  # Take advantage of symmetry\n        k = n - k\n    result = 1\n    for i in range(1, k + 1):\n        result = (result * (n - i + 1)) // i\n    return result\n"}
{"task_id": "Perfect k-ary Tree", "final_solution": "def count_perfect_kary_trees(n, k, edges):\n    # Create an adjacency list to represent the tree\n    adj_list = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    # Initialize a list to store the number of perfect k-ary trees for each node\n    dp = [0] * (n + 1)\n\n    # Define a recursive function to count perfect k-ary trees\n    def count_trees(node, parent):\n        # Base case: if the node has no children, it's a perfect k-ary tree of size 1\n        if not adj_list[node]:\n            return 1\n\n        # Initialize the count of perfect k-ary trees for this node\n        count = 0\n\n        # Recursively count perfect k-ary trees for each child\n        child_counts = []\n        for child in adj_list[node]:\n            if child != parent:\n                child_counts.append(count_trees(child, node))\n\n        # If the node has exactly k children, and each child has a perfect k-ary tree,\n        # then the node itself can be the root of a perfect k-ary tree\n        if len(child_counts) == k:\n            temp = 1\n            for child_count in child_counts:\n                temp *= child_count\n                temp %= (10**9 + 7)\n            count += temp\n\n        # Also consider the trees that can be formed by combining the subtrees\n        for i in range(1, len(child_counts) + 1):\n            if i % k == 0:\n                temp = 1\n                for j in range(i):\n                    temp *= child_counts[j]\n                    temp %= (10**9 + 7)\n                count += temp\n                count %= (10**9 + 7)\n\n        dp[node] = count\n        return count\n\n    # Count perfect k-ary trees for each node\n    total_count = 0\n    for i in range(1, n + 1):\n        total_count += count_trees(i, -1)\n        total_count %= (10**9 + 7)\n\n    # Return the result modulo 10^9 + 7\n    return total_count\n\n\ndef main():\n    n, k = map(int, input().split())\n    edges = []\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n\n    result = count_perfect_kary_trees(n, k, edges)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def count_perfect_kary_trees(n, k, edges):\n    # Create an adjacency list to represent the tree\n    adj_list = [[] for _ in range(n + 1)]\n    for u, v in edges:\n        adj_list[u].append(v)\n        adj_list[v].append(u)\n\n    # Initialize a list to store the number of perfect k-ary trees for each node\n    dp = [0] * (n + 1)\n\n    # Define a recursive function to count perfect k-ary trees\n    def count_trees(node, parent):\n        # Base case: if the node has no children, it's a perfect k-ary tree of size 1\n        if not adj_list[node]:\n            return 1\n\n        # Initialize the count of perfect k-ary trees for this node\n        count = 0\n\n        # Recursively count perfect k-ary trees for each child\n        for child in adj_list[node]:\n            if child != parent:\n                count += count_trees(child, node)\n\n        # If the node has exactly k children, it's a perfect k-ary tree\n        if count == k:\n            dp[node] = 1\n            count += 1\n\n        return count\n\n    # Count perfect k-ary trees for each node\n    for i in range(1, n + 1):\n        count_trees(i, -1)\n\n    # Calculate the total count of perfect k-ary trees\n    total_count = sum(dp)\n\n    # Return the result modulo 10^9 + 7\n    return total_count % (10**9 + 7)\n\n\ndef main():\n    n, k = map(int, input().split())\n    edges = []\n    for _ in range(n - 1):\n        u, v = map(int, input().split())\n        edges.append((u, v))\n\n    result = count_perfect_kary_trees(n, k, edges)\n    print(result)\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Guess the Numbers", "final_solution": "import itertools\nimport re\n\ndef main():\n    while True:\n        line = input().split()\n        if line == ['0', '0']:\n            break\n        n = int(line[0])\n        values = list(map(int, line[1:n+1]))\n        result = int(line[n+1])\n        expression = input()\n        unknowns = re.findall(r'[a-z]', expression)\n        for p in itertools.permutations(values):\n            env = dict(zip(unknowns, p))\n            try:\n                if eval(expression, env) == result:\n                    print('YES')\n                    break\n            except ZeroDivisionError:\n                pass\n        else:\n            print('NO')\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import itertools\nimport re\n\ndef main():\n    while True:\n        line = input().split()\n        if line == ['0', '0']:\n            break\n        n = int(line[0])\n        values = list(map(int, line[1:n+1]))\n        result = int(line[n+1])\n        expression = input()\n        unknowns = re.findall(r'[a-z]', expression)\n        for p in itertools.permutations(values):\n            env = dict(zip(unknowns, p))\n            try:\n                if eval(expression, env) == result:\n                    print('YES')\n                    break\n            except ZeroDivisionError:\n                pass\n        else:\n            print('NO')\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "As Easy as CAB", "final_solution": "from collections import defaultdict, deque\n\ndef main():\n    L, N = input().split()\n    L = ord(L) - 97\n    N = int(N)\n\n    words = [input() for _ in range(N)]\n\n    graph = defaultdict(list)\n    in_degree = [0] * 26\n\n    for i in range(N - 1):\n        for j in range(min(len(words[i]), len(words[i + 1]))):\n            if words[i][j] != words[i + 1][j]:\n                graph[ord(words[i][j]) - 97].append(ord(words[i + 1][j]) - 97)\n                in_degree[ord(words[i + 1][j]) - 97] += 1\n                break\n        else:\n            if len(words[i]) > len(words[i + 1]):\n                print(\"IMPOSSIBLE\")\n                return\n\n    queue = deque([i for i in range(26) if in_degree[i] == 0 and i <= L])\n    result = []\n\n    while queue:\n        node = queue.popleft()\n        result.append(chr(node + 97))\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    if len(result) == L + 1:\n        print(\"\".join(result))\n    elif len(result) < L + 1:\n        print(\"AMBIGUOUS\")\n    else:\n        print(\"IMPOSSIBLE\")\n\nif __name__ == \"__main__\":\n    main()\n\n\nAnd here are the corrected test cases:\n\nimport unittest\nfrom unittest.mock import patch\nfrom io import StringIO\n\nclass TestMainFunction(unittest.TestCase):\n    @patch('builtins.input', side_effect=['d 4', 'cab', 'cda', 'ccc', 'badca'])\n    @patch('sys.stdout', new_callable=StringIO)\n    def test_sample_input_1(self, mock_stdout, mock_input):\n        main()\n        self.assertEqual(mock_stdout.getvalue().strip(), 'adcb')\n\n    @patch('builtins.input', side_effect=['c 4', 'abc', 'bca', 'cab', 'aca'])\n    @patch('sys.stdout', new_callable=StringIO)\n    def test_sample_input_2(self, mock_stdout, mock_input):\n        main()\n        self.assertEqual(mock_stdout.getvalue().strip(), 'IMPOSSIBLE')\n\n    @patch('builtins.input', side_effect=['f 2', 'dea', 'cfb'])\n    @patch('sys.stdout', new_callable=StringIO)\n    def test_sample_input_3(self, mock_stdout, mock_input):\n        main()\n        self.assertEqual(mock_stdout.getvalue().strip(), 'AMBIGUOUS')\n\n    @patch('builtins.input', side_effect=['e 5', 'ebbce', 'dbe', 'adcd', 'bc', 'cd'])\n    @patch('sys.stdout', new_callable=StringIO)\n    def test_sample_input_4(self, mock_stdout, mock_input):\n        main()\n        self.assertEqual(mock_stdout.getvalue().strip(), 'edabc')\n\nif __name__ == \"__main__\":\n    unittest.main()\n", "initial_solution": "from collections import defaultdict, deque\n\ndef main():\n    L, N = input().split()\n    L = ord(L) - 97\n    words = [input() for _ in range(N)]\n\n    graph = defaultdict(list)\n    in_degree = [0] * 26\n\n    for i in range(N - 1):\n        for j in range(min(len(words[i]), len(words[i + 1]))):\n            if words[i][j] != words[i + 1][j]:\n                graph[ord(words[i][j]) - 97].append(ord(words[i + 1][j]) - 97)\n                in_degree[ord(words[i + 1][j]) - 97] += 1\n                break\n        else:\n            if len(words[i]) > len(words[i + 1]):\n                print(\"IMPOSSIBLE\")\n                return\n\n    queue = deque([i for i in range(26) if in_degree[i] == 0 and i <= L])\n    result = []\n\n    while queue:\n        node = queue.popleft()\n        result.append(chr(node + 97))\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n\n    if len(result) == L + 1:\n        print(\"\".join(result))\n    elif len(result) < L + 1:\n        print(\"AMBIGUOUS\")\n    else:\n        print(\"IMPOSSIBLE\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Catmas Gifts", "final_solution": "import math\n\ndef main():\n    n = int(input())\n    expected_gifts = n * sum(1/i for i in range(1, n + 1))\n    print(\"{:.6f}\".format(expected_gifts))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import math\n\ndef main():\n    n = int(input())\n    expected_gifts = n\n    for i in range(1, n):\n        expected_gifts += 1 / (1 - 1 / i)\n    print(\"{:.6f}\".format(expected_gifts))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Hilbert's Hedge Maze", "final_solution": "import collections\n\ndef generate_maze(n):\n    S = 'A'\n    for _ in range(n):\n        T = ''\n        for c in S:\n            if c == 'A':\n                T += 'LBFRAFARFBL'\n            else:\n                T += 'RAFLBFBLFAR'\n        S = T\n    S = S.replace('A', '').replace('B', '')\n    return S\n\ndef move(S):\n    x, y, dx, dy = 0, 0, 1, 0\n    for c in S:\n        if c == 'F':\n            x += dx\n            y += dy\n        elif c == 'R':\n            dx, dy = dy, -dx\n        elif c == 'L':\n            dx, dy = -dy, dx\n        yield (x, y)\n\ndef bfs(maze, x1, y1, x2, y2):\n    queue = collections.deque([(x1, y1, 0)])\n    visited = {(x1, y1)}\n    while queue:\n        x, y, d = queue.popleft()\n        if (x, y) == (x2, y2):\n            return d\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) not in visited and (nx, ny) in maze:\n                queue.append((nx, ny, d + 1))\n                visited.add((nx, ny))\n    return -1\n\ndef main():\n    k = int(input())\n    for _ in range(k):\n        n, x1, y1, x2, y2 = map(int, input().split())\n        maze = set(move(generate_maze(n)))\n        distance = bfs(maze, x1, y1, x2, y2)\n        print(distance)\n\nif __name__ == '__main__':\n    main()\n", "initial_solution": "import collections\n\ndef generate_maze(n):\n    S = 'A'\n    for _ in range(n):\n        T = ''\n        for c in S:\n            if c == 'A':\n                T += 'LBFRAFARFBL'\n            else:\n                T += 'RAFLBFBLFAR'\n        S = T\n    S = S.replace('A', '').replace('B', '')\n    return S\n\ndef move(S):\n    x, y, dx, dy = 0, 0, 1, 0\n    for c in S:\n        if c == 'F':\n            x += dx\n            y += dy\n        elif c == 'R':\n            dx, dy = dy, -dx\n        elif c == 'L':\n            dx, dy = -dy, dx\n        yield (x, y)\n\ndef bfs(maze, x1, y1, x2, y2):\n    queue = collections.deque([(x1, y1, 0)])\n    visited = {(x1, y1)}\n    while queue:\n        x, y, d = queue.popleft()\n        if (x, y) == (x2, y2):\n            return d\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\n            nx, ny = x + dx, y + dy\n            if (nx, ny) not in visited and (nx, ny) in maze:\n                queue.append((nx, ny, d + 1))\n                visited.add((nx, ny))\n    return -1\n\ndef main():\n    k = int(input())\n    for _ in range(k):\n        n, x1, y1, x2, y2 = map(int, input().split())\n        maze = set(move(generate_maze(n)))\n        print(bfs(maze, x1, y1, x2, y2))\n\nif __name__ == '__main__':\n    main()\n"}
{"task_id": "Around the track", "final_solution": "import math\nimport collections\n\ndef calculate_turn(node1, node2, node3):\n    x1, y1 = node1\n    x2, y2 = node2\n    x3, y3 = node3\n    v1 = (x2 - x1, y2 - y1)\n    v2 = (x3 - x2, y3 - y2)\n    cross_product = v1[0] * v2[1] - v1[1] * v2[0]\n    dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n    magnitude1 = math.sqrt(v1[0]**2 + v1[1]**2)\n    magnitude2 = math.sqrt(v2[0]**2 + v2[1]**2)\n    cos_angle = dot_product / (magnitude1 * magnitude2)\n    angle = math.acos(cos_angle)\n    if cross_product < 0:\n        angle = 2 * math.pi - angle\n    return angle\n\ndef find_eulerian_circuit(graph):\n    circuit = []\n    stack = [0]\n    while stack:\n        node = stack[-1]\n        if graph[node]:\n            next_node = graph[node].pop()\n            stack.append(next_node)\n        else:\n            circuit.append(stack.pop())\n    return circuit[::-1]\n\ndef main():\n    N, M = map(int, input().split())\n    nodes = [tuple(map(int, input().split())) for _ in range(N)]\n    graph = collections.defaultdict(list)\n    for _ in range(M):\n        i, j = map(int, input().split())\n        graph[i].append(j)\n        graph[j].append(i)\n    circuit = find_eulerian_circuit(graph)\n    total_turn = 0\n    for i in range(len(circuit) - 2):\n        node1 = nodes[circuit[i]]\n        node2 = nodes[circuit[i+1]]\n        node3 = nodes[circuit[i+2]]\n        angle = calculate_turn(node1, node2, node3)\n        total_turn += angle\n    print(total_turn)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import math\nimport collections\n\ndef calculate_turn(node1, node2, node3):\n    x1, y1 = node1\n    x2, y2 = node2\n    x3, y3 = node3\n    v1 = (x2 - x1, y2 - y1)\n    v2 = (x3 - x2, y3 - y2)\n    dot_product = v1[0] * v2[0] + v1[1] * v2[1]\n    magnitude1 = math.sqrt(v1[0]**2 + v1[1]**2)\n    magnitude2 = math.sqrt(v2[0]**2 + v2[1]**2)\n    cos_angle = dot_product / (magnitude1 * magnitude2)\n    angle = math.acos(cos_angle)\n    return angle\n\ndef find_eulerian_circuit(graph):\n    circuit = []\n    stack = [0]\n    while stack:\n        node = stack[-1]\n        if graph[node]:\n            next_node = graph[node].pop()\n            stack.append(next_node)\n        else:\n            circuit.append(stack.pop())\n    return circuit[::-1]\n\ndef main():\n    N, M = map(int, input().split())\n    nodes = [tuple(map(int, input().split())) for _ in range(N)]\n    graph = collections.defaultdict(list)\n    for _ in range(M):\n        i, j = map(int, input().split())\n        graph[i].append(j)\n        graph[j].append(i)\n    circuit = find_eulerian_circuit(graph)\n    total_turn = 0\n    for i in range(len(circuit) - 2):\n        node1 = nodes[circuit[i]]\n        node2 = nodes[circuit[i+1]]\n        node3 = nodes[circuit[i+2]]\n        total_turn += calculate_turn(node1, node2, node3)\n    print(total_turn)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "3D Printer", "final_solution": "import math\n\ndef calculate_volume(polyhedra):\n    volume = 0\n    for polyhedron in polyhedra:\n        for face in polyhedron:\n            vertices = face[1:]\n            n = len(vertices) // 3\n            vertices = [(vertices[3 * i], vertices[3 * i + 1], vertices[3 * i + 2]) for i in range(n)]\n            area = 0\n            for i in range(n):\n                j = (i + 1) % n\n                area += (vertices[i][0] * vertices[j][1] - vertices[j][0] * vertices[i][1])\n            area = abs(area) / 2\n            normal_x = 0\n            normal_y = 0\n            normal_z = 0\n            for i in range(n):\n                j = (i + 1) % n\n                normal_x += (vertices[i][1] - vertices[j][1]) * (vertices[i][2] + vertices[j][2])\n                normal_y += (vertices[i][2] - vertices[j][2]) * (vertices[i][0] + vertices[j][0])\n                normal_z += (vertices[i][0] - vertices[j][0]) * (vertices[i][1] + vertices[j][1])\n            normal_x /= 6\n            normal_y /= 6\n            normal_z /= 6\n            volume += normal_x * vertices[0][0] + normal_y * vertices[0][1] + normal_z * vertices[0][2]\n    return abs(volume / 6)\n\ndef main():\n    n = int(input())\n    polyhedra = []\n    for _ in range(n):\n        f = int(input())\n        polyhedron = []\n        for _ in range(f):\n            line = input().split()\n            v = int(line[0])\n            vertices = list(map(float, line[1:]))\n            polyhedron.append([v] + vertices)\n        polyhedra.append(polyhedron)\n    volume = calculate_volume(polyhedra)\n    print(\"{:.2f}\".format(volume))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import math\n\ndef calculate_volume(polyhedra):\n    volume = 0\n    for polyhedron in polyhedra:\n        faces = []\n        for face in polyhedron:\n            vertices = face[1:]\n            n = len(vertices) // 3\n            area = 0\n            for i in range(n):\n                j = (i + 1) % n\n                area += (vertices[3 * i] * vertices[3 * j + 1] - vertices[3 * i + 1] * vertices[3 * j])\n            area = abs(area) / 2\n            centroid_x = sum(vertices[::3]) / n\n            centroid_y = sum(vertices[1::3]) / n\n            centroid_z = sum(vertices[2::3]) / n\n            faces.append((area, centroid_x, centroid_y, centroid_z))\n        for i in range(len(faces)):\n            j = (i + 1) % len(faces)\n            area_i, x_i, y_i, z_i = faces[i]\n            area_j, x_j, y_j, z_j = faces[j]\n            volume += (x_i * (y_j - y_i) + x_j * (y_i - y_j)) * (z_i + z_j) / 6\n    return abs(volume)\n\ndef main():\n    n = int(input())\n    polyhedra = []\n    for _ in range(n):\n        f = int(input())\n        polyhedron = []\n        for _ in range(f):\n            v = int(input().split()[0])\n            vertices = list(map(float, input().split()))\n            polyhedron.append([v] + vertices)\n        polyhedra.append(polyhedron)\n    volume = calculate_volume(polyhedra)\n    print(\"{:.2f}\".format(volume))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Saskatchewan", "final_solution": "def is_inside(p, poly):\n    x, y = p\n    n = len(poly)\n    inside = False\n\n    p1x, p1y = poly[0]\n    for i in range(n+1):\n        p2x, p2y = poly[i % n]\n        if y > min(p1y, p2y):\n            if y <= max(p1y, p2y):\n                if x <= max(p1x, p2x):\n                    if p1y != p2y:\n                        xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x\n                    if p1x == p2x or x <= xinters:\n                        inside = not inside\n        p1x, p1y = p2x, p2y\n\n    return inside\n\n\ndef main():\n    n = int(input())\n    poly = [list(map(int, input().split())) for _ in range(n)]\n    min_x = min(x for x, y in poly)\n    max_x = max(x for x, y in poly)\n    min_y = min(y for x, y in poly)\n    max_y = max(y for x, y in poly)\n    count = 0\n    for y in range(min_y, max_y + 1):\n        events = []\n        for p1, p2 in zip(poly, poly[1:] + [poly[0]]):\n            if min(p1[1], p2[1]) <= y <= max(p1[1], p2[1]):\n                if p1[1] != p2[1]:\n                    xinters = (y - p1[1]) * (p2[0] - p1[0]) / (p2[1] - p1[1]) + p1[0]\n                else:\n                    xinters = p1[0]\n                events.append((xinters, 1 if p1[1] < p2[1] else -1))\n        events.sort()\n        inside = 0\n        for _, event in events:\n            inside += event\n            if inside > 0:\n                count += 1\n    print(count)\n\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def is_inside(p, poly):\n    x, y = p\n    n = len(poly)\n    inside = False\n\n    p1x, p1y = poly[0]\n    for i in range(n+1):\n        p2x, p2y = poly[i % n]\n        if y > min(p1y, p2y):\n            if y <= max(p1y, p2y):\n                if x <= max(p1x, p2x):\n                    if p1y != p2y:\n                        xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x\n                    if p1x == p2x or x <= xinters:\n                        inside = not inside\n        p1x, p1y = p2x, p2y\n\n    return inside\n\n\ndef main():\n    poly = [list(map(int, input().split())) for _ in range(int(input()))]\n    count = 0\n    for x in range(max(x for x, y in poly)):\n        for y in range(max(y for x, y in poly)):\n            if is_inside((x, y), poly):\n                count += 1\n    print(count)\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Eccentric Excursion", "final_solution": "from collections import defaultdict, deque\n\ndef main():\n    n, k = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    if k == 0:\n        if n > 2:\n            print(-1)\n            return\n        else:\n            print(' '.join(map(str, range(1, n + 1))))\n            return\n\n    visited = [False] * (n + 1)\n    path = []\n    if not dfs(graph, 1, visited, path, k, 0):\n        print(-1)\n    else:\n        print(' '.join(map(str, path)))\n\n\ndef dfs(graph, node, visited, path, k, flights_taken):\n    visited[node] = True\n    path.append(node)\n    if len(path) == len(graph):\n        if flights_taken == k:\n            return True\n        else:\n            path.pop()\n            visited[node] = False\n            return False\n    for neighbor in sorted(graph[node]):\n        if not visited[neighbor]:\n            if dfs(graph, neighbor, visited, path, k, flights_taken):\n                return True\n            if flights_taken < k:\n                for other_node in range(1, n + 1):\n                    if other_node not in graph[node] and other_node not in path:\n                        if dfs(graph, other_node, visited, path, k, flights_taken + 1):\n                            return True\n    path.pop()\n    visited[node] = False\n    return False\n\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "from collections import defaultdict, deque\n\ndef main():\n    n, k = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(n - 1):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n\n    if k == 0:\n        print(-1)\n        return\n\n    visited = [False] * (n + 1)\n    path = []\n    dfs(graph, 1, visited, path, k)\n\n    if len(path) != n:\n        print(-1)\n    else:\n        print(' '.join(map(str, path)))\n\n\ndef dfs(graph, node, visited, path, k):\n    visited[node] = True\n    path.append(node)\n    if len(path) == len(graph):\n        return True\n    for neighbor in graph[node]:\n        if not visited[neighbor]:\n            if dfs(graph, neighbor, visited, path, k - 1):\n                return True\n    path.pop()\n    visited[node] = False\n    return False\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Div 2, Mul 2, Mul 3", "final_solution": "from collections import Counter, deque\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        nums = list(map(int, input().split()))\n        counter = Counter(nums)\n        \n        if 1 not in counter:\n            print(\"NO\")\n            continue\n        \n        queue = deque([(1, [1])])\n        found = False\n        while queue:\n            num, path = queue.popleft()\n            if len(path) == n:\n                if all(x in counter for x in path):\n                    print(\"YES\")\n                    print(' '.join(map(str, path)))\n                    found = True\n                    break\n            else:\n                if num * 2 in counter:\n                    queue.append((num * 2, path + [num * 2]))\n                if num * 3 in counter:\n                    queue.append((num * 3, path + [num * 3]))\n                if num % 2 == 0 and num // 2 in counter:\n                    queue.append((num // 2, path + [num // 2]))\n        if not found:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "from collections import Counter\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        nums = list(map(int, input().split()))\n        counter = Counter(nums)\n        \n        if 1 not in counter:\n            print(\"NO\")\n            continue\n        \n        dp = [0] * (10**6 + 1)\n        dp[1] = 1\n        \n        for num in counter:\n            if num % 2 == 0:\n                dp[num] = max(dp[num], dp[num // 2])\n            dp[num] = max(dp[num], dp[num // 3] if num % 3 == 0 else 0)\n            dp[num] = max(dp[num], dp[num // 2])\n        \n        if dp[max(nums)] == 0:\n            print(\"NO\")\n        else:\n            print(\"YES\")\n            res = []\n            num = max(nums)\n            while num > 1:\n                if num % 2 == 0 and dp[num // 2] == dp[num]:\n                    num //= 2\n                elif num % 3 == 0 and dp[num // 3] == dp[num]:\n                    num //= 3\n                else:\n                    num //= 2\n                res.append(num)\n            res.append(1)\n            print(' '.join(map(str, res[::-1])))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Blacksmith Training", "final_solution": "import heapq\n\ndef main():\n    n = int(input())\n    plans = []\n    for _ in range(n):\n        e, m, p, d = map(int, input().split())\n        plans.append((e, m, p, d))\n    plans.sort()\n\n    dp = [float('inf')] * 301\n    dp[0] = 0\n    pq = [(0, 0)]\n\n    while pq:\n        cost, skill = heapq.heappop(pq)\n        if cost > dp[skill]:\n            continue\n        for e, m, p, d in plans:\n            if e > skill:\n                break\n            new_cost = cost + p\n            for i in range(e, min(m + 1, 301)):\n                new_cost += d\n                if new_cost < dp[i]:\n                    dp[i] = new_cost\n                    heapq.heappush(pq, (new_cost, i))\n\n    print(dp[300])\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import heapq\n\ndef main():\n    n = int(input())\n    plans = []\n    for _ in range(n):\n        e, m, p, d = map(int, input().split())\n        plans.append((e, m, p, d))\n    plans.sort()\n\n    dp = [float('inf')] * 301\n    dp[0] = 0\n    pq = [(0, 0)]\n\n    while pq:\n        cost, skill = heapq.heappop(pq)\n        if cost > dp[skill]:\n            continue\n        for e, m, p, d in plans:\n            if e <= skill:\n                for i in range(e, min(m + 1, 301)):\n                    new_cost = cost + p + (i - e) * d\n                    if new_cost < dp[i]:\n                        dp[i] = new_cost\n                        heapq.heappush(pq, (new_cost, i))\n\n    print(dp[300])\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Magical Distances", "final_solution": "import heapq\n\ndef main():\n    n, m = map(int, input().split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b, w = map(int, input().split())\n        graph[a].append((b, w))\n        graph[b].append((a, w))\n\n    q = int(input())\n    for _ in range(q):\n        s, t = map(int, input().split())\n        dist = dijkstra(graph, s, t)\n        print(dist)\n\n\ndef dijkstra(graph, start, end):\n    dist = [float('inf')] * (len(graph))\n    dist[start - 1] = 0\n    pq = [(0, start)]\n    while pq:\n        curr_dist, curr_node = heapq.heappop(pq)\n        if curr_node == end:\n            return curr_dist\n        for neighbor, weight in graph[curr_node]:\n            new_dist = curr_dist | weight\n            if new_dist < dist[neighbor - 1]:\n                dist[neighbor - 1] = new_dist\n                heapq.heappush(pq, (new_dist, neighbor))\n    return -1\n\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import heapq\n\ndef main():\n    n, m = map(int, input().split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        a, b, w = map(int, input().split())\n        graph[a].append((b, w))\n        graph[b].append((a, w))\n\n    q = int(input())\n    for _ in range(q):\n        s, t = map(int, input().split())\n        dist = dijkstra(graph, s, t)\n        print(dist)\n\n\ndef dijkstra(graph, start, end):\n    dist = [float('inf')] * (len(graph))\n    dist[start - 1] = 0\n    pq = [(0, start)]\n    while pq:\n        curr_dist, curr_node = heapq.heappop(pq)\n        if curr_node == end:\n            return curr_dist\n        for neighbor, weight in graph[curr_node]:\n            new_dist = curr_dist | weight\n            if new_dist < dist[neighbor - 1]:\n                dist[neighbor - 1] = new_dist\n                heapq.heappush(pq, (new_dist, neighbor))\n    return -1\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Pipes", "final_solution": "import sys\n\ndef tsp(graph, start):\n    n = len(graph)\n    dp = [[float('inf')] * n for _ in range(1 << n)]\n    dp[1 << start][start] = 0\n    for mask in range(1 << n):\n        for x in range(n):\n            if not (mask & (1 << x)):\n                continue\n            for y in range(n):\n                if x == y or not (mask & (1 << y)):\n                    continue\n                new_mask = mask ^ (1 << x)\n                dp[mask][x] = min(dp[mask][x], dp[new_mask][y] + graph[y][x])\n    return min(dp[-1][i] + graph[i][start] for i in range(n))\n\ndef main():\n    n = int(input())\n    for _ in range(n):\n        r, c = map(int, input().split())\n        graph = [[0] * (r * c) for _ in range(r * c)]\n        for i in range(r * 2 - 1):\n            line = input()\n            if i % 2 == 0:\n                for j in range((len(line) - 1) // 2):\n                    if line[j * 2 + 1].isdigit():\n                        cost = int(line[j * 2 + 1])\n                        graph[i // 2 * c + j][(i // 2 + 1) * c + j] = cost\n                        graph[(i // 2 + 1) * c + j][i // 2 * c + j] = cost\n            else:\n                for j in range((len(line) - 1) // 2):\n                    if line[j * 2 + 1].isdigit():\n                        cost = int(line[j * 2 + 1])\n                        graph[i // 2 * c + j][(i // 2) * c + j + 1] = cost\n                        graph[(i // 2) * c + j + 1][i // 2 * c + j] = cost\n        print(tsp(graph, 0))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import sys\n\ndef tsp(graph, start):\n    n = len(graph)\n    dp = [[float('inf')] * n for _ in range(1 << n)]\n    dp[1 << start][start] = 0\n    for mask in range(1 << n):\n        for x in range(n):\n            if not (mask & (1 << x)):\n                continue\n            for y in range(n):\n                if x == y or not (mask & (1 << y)):\n                    continue\n                new_mask = mask ^ (1 << x)\n                dp[mask][x] = min(dp[mask][x], dp[new_mask][y] + graph[y][x])\n    return min(dp[-1][i] + graph[i][start] for i in range(n))\n\ndef main():\n    n = int(input())\n    for _ in range(n):\n        r, c = map(int, input().split())\n        graph = [[0] * (r * c) for _ in range(r * c)]\n        for i in range(r):\n            input()\n            for j in range(c):\n                for k in range(2):\n                    for l in range(2):\n                        if k == 0 and l == 0:\n                            continue\n                        x = i * 2 + k\n                        y = j * 2 + l\n                        if x < 2 * r and y < 2 * c:\n                            graph[i * c + j][(x - k) // 2 * c + (y - l) // 2] = int(input()[2 * l + 1])\n        print(tsp(graph, 0))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Special Cycle", "final_solution": "from collections import defaultdict\n\ndef main():\n    n, m, k = map(int, input().split())\n    graph = defaultdict(list)\n    special_edges = set()\n    \n    for i in range(m):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n        if i < k:\n            special_edges.add((a, b))\n            special_edges.add((b, a))\n    \n    visited = set()\n    cycle = []\n    found = False\n    \n    def dfs(node, parent, path):\n        nonlocal found\n        visited.add(node)\n        path.append(node)\n        for neighbor in graph[node]:\n            if neighbor == parent:\n                continue\n            if neighbor in path:\n                if path.index(neighbor) != len(path) - 1:\n                    nonlocal cycle\n                    cycle.extend(path[path.index(neighbor):])\n                    found = True\n                    return\n            else:\n                dfs(neighbor, node, path)\n                if found:\n                    return\n        path.pop()\n    \n    for node in range(1, n + 1):\n        if node not in visited:\n            dfs(node, -1, [])\n            if found:\n                break\n    \n    if found:\n        # Check if the cycle is valid\n        valid = True\n        for edge in special_edges:\n            if (edge[0] in cycle and edge[1] not in cycle) or (edge[0] not in cycle and edge[1] in cycle):\n                valid = False\n                break\n            if edge[0] not in cycle and edge[1] not in cycle:\n                for node in cycle:\n                    if node in graph[edge[0]] or node in graph[edge[1]]:\n                        valid = False\n                        break\n                if not valid:\n                    break\n        if valid:\n            print(len(cycle))\n            for node in cycle:\n                print(node)\n        else:\n            print(-1)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "from collections import defaultdict\n\ndef main():\n    n, m, k = map(int, input().split())\n    graph = defaultdict(list)\n    special_edges = set()\n    \n    for i in range(m):\n        a, b = map(int, input().split())\n        graph[a].append(b)\n        graph[b].append(a)\n        if i < k:\n            special_edges.add((a, b))\n            special_edges.add((b, a))\n    \n    visited = set()\n    cycle = []\n    found = False\n    \n    def dfs(node, parent):\n        nonlocal found\n        visited.add(node)\n        for neighbor in graph[node]:\n            if neighbor == parent:\n                continue\n            if neighbor in visited:\n                if neighbor not in cycle:\n                    cycle.append(neighbor)\n                    found = True\n            else:\n                cycle.append(node)\n                dfs(neighbor, node)\n                if found:\n                    return\n                cycle.pop()\n    \n    for node in range(1, n + 1):\n        if node not in visited:\n            cycle.append(node)\n            dfs(node, -1)\n            if found:\n                break\n    \n    if found:\n        print(len(cycle))\n        for node in cycle:\n            print(node)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Barking Up The Wrong Tree", "final_solution": "import math\nimport heapq\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef dijkstra(start, end, obstacles):\n    queue = [(0, start)]\n    visited = set()\n    while queue:\n        dist, pos = heapq.heappop(queue)\n        if pos == end:\n            return dist\n        if pos in visited:\n            continue\n        visited.add(pos)\n        for dx in range(-1, 2):\n            for dy in range(-1, 2):\n                new_pos = (pos[0] + dx, pos[1] + dy)\n                if new_pos not in obstacles and new_pos != pos:\n                    heapq.heappush(queue, (dist + distance(pos, new_pos), new_pos))\n    return float('inf')\n\ndef main():\n    n, m = map(int, input().split())\n    toys = [tuple(map(int, input().split())) for _ in range(n)]\n    trees = set(tuple(map(int, input().split())) for _ in range(m))\n    leash_length = 0\n    current_position = (0, 0)\n    for toy in toys:\n        leash_length += dijkstra(current_position, toy, trees)\n        current_position = toy\n    print(\"{:.2f}\".format(leash_length))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef main():\n    n, m = map(int, input().split())\n    toys = [list(map(int, input().split())) for _ in range(n)]\n    trees = [list(map(int, input().split())) for _ in range(m)]\n    leash_length = 0\n    current_position = [0, 0]\n    for toy in toys:\n        leash_length += distance(current_position, toy)\n        current_position = toy\n    print(\"{:.2f}\".format(leash_length))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "The Wire Ghost", "final_solution": "import sys\n\ndef main():\n    L, n = map(int, input().split())\n    events = []\n    for _ in range(n):\n        x, direction = input().split()\n        x = int(x)\n        if direction == 'C':\n            events.append((x, -1))\n        else:\n            events.append((x, 1))\n\n    events.sort()\n\n    stack = []\n    for x, direction in events:\n        while stack and stack[-1][0] < x:\n            stack.pop()\n        if stack and stack[-1][1] != direction:\n            print(\"GHOST\")\n            sys.exit()\n        stack.append((x, direction))\n\n    print(\"SAFE\")\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import math\n\ndef main():\n    L, n = map(int, input().split())\n    events = []\n    for _ in range(n):\n        x, direction = input().split()\n        x = int(x)\n        if direction == 'C':\n            events.append((x, -1))\n        else:\n            events.append((x, 1))\n\n    events.sort()\n\n    stack = []\n    for x, direction in events:\n        while stack and stack[-1][0] < x:\n            stack.pop()\n        if stack and stack[-1][1] != direction:\n            print(\"GHOST\")\n            return\n        stack.append((x, direction))\n\n    print(\"SAFE\")\n\nif __name__ == \"__main__\":\n    main()\n"}
