{"task_id": "Left and Right", "final_solution": "def main():\n    n = int(input())\n    directions = input()\n\n    order = list(range(1, n + 1))\n    result = [1]\n\n    for direction in directions:\n        if direction == 'L':\n            for house in order[1:]:\n                if house < result[-1]:\n                    result.append(house)\n                    order.remove(house)\n                    break\n        else:\n            for house in order[1:][::-1]:\n                if house > result[-1]:\n                    result.append(house)\n                    order.remove(house)\n                    break\n\n    result.extend(order)\n    for house in result:\n        print(house)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    n = int(input())\n    directions = input()\n\n    order = [0] * n\n    current_house = 1\n    order[0] = current_house\n\n    for direction in directions:\n        if direction == 'L':\n            current_house -= 1\n        else:\n            current_house += 1\n        order[order.index(0)] = current_house\n\n    for house in order:\n        print(house)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Combination Lock", "final_solution": "def main():\n    while True:\n        numbers = list(map(int, input().split()))\n        if numbers == [0, 0, 0, 0]:\n            break\n        initial, num1, num2, num3 = numbers\n        total_turns = 2 * 360  # 2 full turns clockwise\n        total_turns += min((num1 - initial) % 40, (40 - initial + num1) % 40) * 9  # turn to first number\n        total_turns += 360  # 1 full turn counter-clockwise\n        total_turns += min((num2 - num1) % 40, (40 - num1 + num2) % 40) * 9  # turn to second number\n        total_turns += min((num3 - num2) % 40, (40 - num2 + num3) % 40) * 9  # turn to third number\n        print(total_turns)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    while True:\n        numbers = list(map(int, input().split()))\n        if numbers == [0, 0, 0, 0]:\n            break\n        initial, num1, num2, num3 = numbers\n        total_turns = 2 * 360  # 2 full turns clockwise\n        total_turns += (num1 - initial) % 40 * 9  # turn to first number\n        total_turns += 360  # 1 full turn counter-clockwise\n        total_turns += (num2 - num1) % 40 * 9  # turn to second number\n        total_turns += (num3 - num2) % 40 * 9  # turn to third number\n        print(total_turns)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "The Uxuhul Voting System", "final_solution": "from itertools import product\n\ndef uxuhul_voting(input_str):\n    def get_outcome(prefs):\n        stones = [0, 0, 0]  # Initialize stones to all 'N'\n        for pref in prefs:\n            # Find the outcome that will maximize the total preference\n            max_pref = float('-inf')\n            flip_stone = -1\n            for i, outcome in enumerate(product('NY', repeat=3)):\n                new_stones = list(stones)\n                for j, stone in enumerate(outcome):\n                    if stone == 'Y':\n                        new_stones[j] = 1\n                    else:\n                        new_stones[j] = 0\n                new_pref = sum(pref[7 - i] for i, stone in enumerate(outcome) if stone == 'Y')\n                if new_pref > max_pref:\n                    max_pref = new_pref\n                    flip_stone = j\n            # Flip the stone that maximizes the total preference\n            stones[flip_stone] = 1 - stones[flip_stone]\n        return ''.join('Y' if stone else 'N' for stone in stones)\n\n    input_lines = input_str.split('\\n')\n    n = int(input_lines[0])\n    output = []\n    line_index = 1\n    for _ in range(n):\n        m = int(input_lines[line_index])\n        line_index += 1\n        prefs = []\n        for _ in range(m):\n            if line_index < len(input_lines):\n                pref = list(map(int, input_lines[line_index].split()))\n                prefs.append(pref)\n                line_index += 1\n            else:\n                break\n        output.append(get_outcome(prefs))\n    return '\\n'.join(output)\n\ndef main():\n    input_str = input('Enter the input:\\n')\n    print(uxuhul_voting(input_str))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "from itertools import product\n\ndef uxuhul_voting():\n    def get_outcome(prefs):\n        stones = [0, 0, 0]  # Initialize stones to all 'N'\n        for pref in prefs:\n            # Find the outcome that will maximize the total preference\n            max_pref = float('-inf')\n            flip_stone = -1\n            for i, outcome in enumerate(product('NY', repeat=3)):\n                new_stones = list(stones)\n                for j, stone in enumerate(outcome):\n                    if stone == 'Y':\n                        new_stones[j] = 1\n                    else:\n                        new_stones[j] = 0\n                new_pref = sum(pref[7 - i] for i, stone in enumerate(outcome) if stone == 'Y')\n                if new_pref > max_pref:\n                    max_pref = new_pref\n                    flip_stone = j\n            # Flip the stone that maximizes the total preference\n            stones[flip_stone] = 1 - stones[flip_stone]\n        return ''.join('Y' if stone else 'N' for stone in stones)\n\n    n = int(input())\n    for _ in range(n):\n        m = int(input())\n        prefs = []\n        for _ in range(m):\n            pref = list(map(int, input().split()))\n            prefs.append(pref)\n        print(get_outcome(prefs))\n\nif __name__ == \"__main__\":\n    uxuhul_voting()\n"}
{"task_id": "Crop Triangles (Easy)", "final_solution": "def main():\n    T = int(input())\n    for case in range(1, T + 1):\n        n, A, B, C, D, x0, y0, M = map(int, input().split())\n        trees = [(x0, y0)]\n        x, y = x0, y0\n        for _ in range(n - 1):\n            x = (A * x + B) % M\n            y = (C * y + D) % M\n            trees.append((x, y))\n        \n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    x1, y1 = trees[i]\n                    x2, y2 = trees[j]\n                    x3, y3 = trees[k]\n                    cx = (x1 + x2 + x3) // 3\n                    cy = (y1 + y2 + y3) // 3\n                    if (x1 + x2 + x3) % 3 == 0 and (y1 + y2 + y3) % 3 == 0 and cx == (x1 + x2 + x3) // 3 and cy == (y1 + y2 + y3) // 3:\n                        count += 1\n        \n        print(f\"Case #{case}: {count}\")\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    T = int(input())\n    for case in range(1, T + 1):\n        n, A, B, C, D, x0, y0, M = map(int, input().split())\n        trees = [(x0, y0)]\n        x, y = x0, y0\n        for _ in range(n - 1):\n            x = (A * x + B) % M\n            y = (C * y + D) % M\n            trees.append((x, y))\n        \n        count = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                for k in range(j + 1, n):\n                    x1, y1 = trees[i]\n                    x2, y2 = trees[j]\n                    x3, y3 = trees[k]\n                    cx = (x1 + x2 + x3) // 3\n                    cy = (y1 + y2 + y3) // 3\n                    if (x1 + x2 + x3) % 3 == 0 and (y1 + y2 + y3) % 3 == 0 and (cx, cy) in trees:\n                        count += 1\n        \n        print(f\"Case #{case}: {count}\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Relatives", "final_solution": "import math\n\ndef euler_totient(n):\n    result = n\n    p = 2\n    while p * p <= n:\n        if n % p == 0:\n            while n % p == 0:\n                n //= p\n            result -= result // p\n        p += 1\n    if n > 1:\n        result -= result // n\n    return result\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        print(euler_totient(n))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import math\n\ndef euler_totient(n):\n    result = n\n    p = 2\n    while p * p <= n:\n        if n % p == 0:\n            while n % p == 0:\n                n //= p\n            result -= result // p\n        p += 1\n    if n > 1:\n        result -= result // n\n    return result\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        print(euler_totient(n))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Bank Queue", "final_solution": "import heapq\n\ndef main():\n    N, T = map(int, input().split())\n    people = []\n    for _ in range(N):\n        c, t = map(int, input().split())\n        people.append((t, c))\n    people.sort()\n    pq = []\n    total_cash = 0\n    time = 0\n    i = 0\n    while time < T:\n        while i < N and people[i][0] <= time:\n            heapq.heappush(pq, -people[i][1])  # Push the negative value to simulate a max heap\n            i += 1\n        if pq:\n            total_cash -= heapq.heappop(pq)  # Subtract the maximum cash from the total cash\n        time += 1\n    print(total_cash)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import heapq\n\ndef main():\n    N, T = map(int, input().split())\n    people = []\n    for _ in range(N):\n        c, t = map(int, input().split())\n        people.append((t, c))\n    people.sort()\n    pq = []\n    total_cash = 0\n    for t, c in people:\n        if t <= T:\n            heapq.heappush(pq, c)\n            if len(pq) > T - t:\n                total_cash -= heapq.heappop(pq)\n            total_cash += c\n    print(total_cash)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Guessing Game", "final_solution": "import sys\n\ndef main():\n    while True:\n        guesses = []\n        while True:\n            guess = int(input())\n            if guess == 0:\n                break\n            response = input()\n            if response == \"right on\":\n                correct_guess = guess\n                break\n            guesses.append((guess, response))\n        if guess == 0:\n            return\n        low_guesses = [guess for guess, response in guesses if response == \"too low\"]\n        high_guesses = [guess for guess, response in guesses if response == \"too high\"]\n        if (any(guess >= correct_guess for guess in low_guesses) or\n            any(guess <= correct_guess for guess in high_guesses)):\n            print(\"Stan is dishonest\")\n        else:\n            print(\"Stan may be honest\")\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    while True:\n        guesses = []\n        while True:\n            guess = int(input())\n            if guess == 0:\n                return\n            response = input()\n            if response == \"right on\":\n                correct_guess = guess\n                break\n            guesses.append((guess, response))\n        low_guesses = [guess for guess, response in guesses if response == \"too low\"]\n        high_guesses = [guess for guess, response in guesses if response == \"too high\"]\n        if (any(guess > correct_guess for guess in low_guesses) or\n            any(guess < correct_guess for guess in high_guesses)):\n            print(\"Stan is dishonest\")\n        else:\n            print(\"Stan may be honest\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Phone List", "final_solution": "def is_consistent(phone_numbers):\n    phone_numbers.sort()\n    for i in range(len(phone_numbers) - 1):\n        if phone_numbers[i + 1].startswith(phone_numbers[i]):\n            return False\n    return True\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        phone_numbers = [input() for _ in range(n)]\n        if is_consistent(phone_numbers):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def is_consistent(phone_numbers):\n    phone_numbers.sort()\n    for i in range(len(phone_numbers) - 1):\n        if phone_numbers[i + 1].startswith(phone_numbers[i]):\n            return False\n    return True\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        phone_numbers = [input() for _ in range(n)]\n        if is_consistent(phone_numbers):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Collapse", "final_solution": "from collections import defaultdict\n\ndef main():\n    N = int(input())\n    islands = defaultdict(list)\n    thresholds = [0] * (N + 1)\n    for i in range(1, N + 1):\n        T, K = map(int, input().split())\n        thresholds[i] = T\n        for _ in range(K):\n            S, V = map(int, input().split())\n            islands[S].append((i, V))\n\n    dead_islands = {1}\n    while dead_islands:\n        new_dead_islands = set()\n        for island in dead_islands:\n            for neighbor, _ in islands[island]:\n                thresholds[neighbor] -= sum(V for i, V in islands[island] if i == neighbor)\n                if thresholds[neighbor] <= 0:\n                    new_dead_islands.add(neighbor)\n        dead_islands = new_dead_islands\n\n    print(sum(1 for t in thresholds[1:] if t > 0))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "from collections import defaultdict\n\ndef main():\n    N = int(input())\n    islands = defaultdict(list)\n    thresholds = [0] * (N + 1)\n    for i in range(1, N + 1):\n        T, K = map(int, input().split())\n        thresholds[i] = T\n        for _ in range(K):\n            S, V = map(int, input().split())\n            islands[S].append((i, V))\n\n    dead_islands = {1}\n    while dead_islands:\n        new_dead_islands = set()\n        for island in dead_islands:\n            for neighbor, _ in islands[island]:\n                thresholds[neighbor] -= sum(V for i, V in islands[island] if i == neighbor)\n                if thresholds[neighbor] <= 0:\n                    new_dead_islands.add(neighbor)\n        dead_islands = new_dead_islands\n\n    print(sum(1 for t in thresholds[1:] if t > 0))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Button Bashing", "final_solution": "from collections import deque\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n, target = map(int, input().split())\n        buttons = list(map(int, input().split()))\n        queue = deque([(0, 0)])  # (time, presses)\n        visited = set([0])\n        min_extra = float('inf')\n        min_presses = float('inf')\n        while queue:\n            time, presses = queue.popleft()\n            if time == target:\n                print(presses, 0)\n                break\n            for button in buttons:\n                new_time = time + button\n                if new_time < 0:\n                    new_time = 0\n                elif new_time > 3600:\n                    new_time = 3600\n                if new_time not in visited:\n                    visited.add(new_time)\n                    queue.append((new_time, presses + 1))\n                    if new_time >= target and new_time - target < min_extra:\n                        min_extra = new_time - target\n                        min_presses = presses + 1\n        else:\n            print(min_presses, min_extra)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "from collections import deque\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n, target = map(int, input().split())\n        buttons = list(map(int, input().split()))\n        queue = deque([(0, 0)])  # (time, presses)\n        visited = set([0])\n        while queue:\n            time, presses = queue.popleft()\n            if time == target:\n                print(presses, 0)\n                break\n            for button in buttons:\n                new_time = time + button\n                if new_time < 0:\n                    new_time = 0\n                elif new_time > 3600:\n                    new_time = 3600\n                if new_time not in visited:\n                    visited.add(new_time)\n                    queue.append((new_time, presses + 1))\n        else:\n            min_extra = float('inf')\n            min_presses = float('inf')\n            for time in visited:\n                if time >= target:\n                    extra = time - target\n                    if extra < min_extra:\n                        min_extra = extra\n                        min_presses = list(visited).index(time) + 1\n            print(min_presses, min_extra)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Biased Standings", "final_solution": "import sys\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        input()  # skip blank line\n        N = int(input())\n        teams = []\n        for _ in range(N):\n            name, pref = input().split()\n            teams.append((int(pref), name))\n        teams.sort()\n        badness = sum(abs(i - pref) for i, (pref, _) in enumerate(teams, 1))\n        print(badness)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import sys\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        input()  # skip blank line\n        N = int(input())\n        teams = []\n        for _ in range(N):\n            name, pref = input().split()\n            teams.append((int(pref), name))\n        teams.sort()\n        badness = sum(abs(i - pref) for i, (pref, _) in enumerate(teams, 1))\n        print(badness)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Fridge", "final_solution": "def main():\n    digits = input()\n    available_digits = set(digits)\n    available_digits = sorted(list(available_digits))\n    \n    num = 1\n    while True:\n        str_num = str(num)\n        can_be_made = True\n        temp_digits = available_digits.copy()\n        for digit in str_num:\n            if digit not in temp_digits:\n                can_be_made = False\n                break\n            temp_digits.remove(digit)\n        if not can_be_made:\n            print(num)\n            break\n        num += 1\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "from itertools import permutations\n\ndef main():\n    digits = input()\n    available_digits = set(digits)\n    available_digits = sorted(list(available_digits))\n    \n    num = 1\n    while True:\n        str_num = str(num)\n        can_be_made = True\n        for digit in str_num:\n            if digit not in available_digits:\n                can_be_made = False\n                break\n            available_digits.remove(digit)\n        if not can_be_made:\n            print(num)\n            break\n        num += 1\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Dividing Sequence", "final_solution": "def main():\n    N = int(input())\n    dp = [1] * (N + 1)\n    parent = [-1] * (N + 1)\n    for i in range(1, N + 1):\n        for j in range(1, i):\n            if i % j == 0 and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n                parent[i] = j\n    max_length = max(dp)\n    max_index = dp.index(max_length)\n    sequence = []\n    while max_index != -1:\n        sequence.append(max_index)\n        max_index = parent[max_index]\n    sequence.reverse()\n    print(max_length)\n    print(' '.join(map(str, sequence)))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    N = int(input())\n    dp = [1] * (N + 1)\n    parent = [-1] * (N + 1)\n    for i in range(1, N + 1):\n        for j in range(i):\n            if i % j == 0 and dp[i] < dp[j] + 1:\n                dp[i] = dp[j] + 1\n                parent[i] = j\n    max_length = max(dp)\n    max_index = dp.index(max_length)\n    sequence = []\n    while max_index != -1:\n        sequence.append(max_index)\n        max_index = parent[max_index]\n    sequence.reverse()\n    print(max_length)\n    print(' '.join(map(str, sequence)))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Open Source", "final_solution": "from collections import defaultdict\n\ndef main():\n    while True:\n        projects = defaultdict(set)\n        students = set()\n        while True:\n            line = input()\n            if line == '1':\n                break\n            elif line == '0':\n                return\n            elif line.isupper():\n                project = line\n            else:\n                if line not in students:\n                    students.add(line)\n                    projects[project].add(line)\n        for project, student_set in sorted(projects.items(), key=lambda x: (-len(x[1]), x[0])):\n            if len(student_set) > 0:\n                print(f\"{project} {len(student_set)}\")\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "from collections import defaultdict\n\ndef main():\n    while True:\n        projects = defaultdict(set)\n        students = set()\n        while True:\n            line = input()\n            if line == '1':\n                break\n            if line.isupper():\n                project = line\n            else:\n                if line not in students:\n                    students.add(line)\n                    projects[project].add(line)\n        if not projects:\n            break\n        for project, student_set in sorted(projects.items(), key=lambda x: (-len(x[1]), x[0])):\n            print(f\"{project} {len(student_set)}\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Candy Distribution", "final_solution": "import math\n\ndef extended_gcd(a, b):\n    if a == 0:\n        return b, 0, 1\n    else:\n        gcd, x, y = extended_gcd(b % a, a)\n        return gcd, y - (b // a) * x, x\n\ndef mod_inv(a, m):\n    gcd, x, y = extended_gcd(a, m)\n    if gcd != 1:\n        return None\n    else:\n        return x % m\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        k, c = map(int, input().split())\n        inv_k = mod_inv(k, c)\n        if inv_k is None:\n            print(\"IMPOSSIBLE\")\n        else:\n            x = (inv_k * (c - 1)) % c\n            bags = (k * x + 1) // c\n            if bags > 10**9:\n                print(\"IMPOSSIBLE\")\n            else:\n                print(bags)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    t = int(input())\n    for _ in range(t):\n        k, c = map(int, input().split())\n        x = 1\n        while True:\n            if (k * x) + 1 % c == 0:\n                print(((k * x) + 1) // c)\n                break\n            x += 1\n            if x > 10**9:\n                print(\"IMPOSSIBLE\")\n                break\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Card Magic", "final_solution": "def main():\n    MOD = 1000000009\n    N, K, T = map(int, input().split())\n    dp = [[0]*(T+1) for _ in range(N+1)]\n    dp[0][0] = 1\n    for i in range(1, N+1):\n        for j in range(1, T+1):\n            for k in range(1, min(j, K)+1):\n                dp[i][j] = (dp[i][j] + dp[i-1][j-k]) % MOD\n    print(dp[N][T])\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    MOD = 1000000009\n    N, K, T = map(int, input().split())\n    dp = [[0]*(T+1) for _ in range(N+1)]\n    dp[0][0] = 1\n    for i in range(1, N+1):\n        for j in range(1, T+1):\n            for k in range(1, min(j, K)+1):\n                dp[i][j] = (dp[i][j] + dp[i-1][j-k]) % MOD\n    print(dp[N][T])\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Rimski", "final_solution": "def main():\n    roman_numerals = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100}\n    roman_keys = sorted(roman_numerals, key=roman_numerals.get, reverse=True)\n\n    B = input()\n    B_values = [roman_numerals[i] for i in B]\n    B_values.sort(reverse=True)\n\n    total = sum(B_values)\n    result = ''\n    for value in sorted(roman_numerals.values(), reverse=True):\n        while total >= value:\n            for key in roman_keys:\n                if roman_numerals[key] == value:\n                    result += key\n                    total -= value\n                    break\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    roman_numerals = {'I': 1, 'V': 5, 'X': 10, 'L': 50, 'C': 100}\n    roman_keys = sorted(roman_numerals, key=roman_numerals.get, reverse=True)\n\n    B = input()\n    B_values = [roman_numerals[i] for i in B]\n    B_values.sort(reverse=True)\n\n    result = ''\n    for value in B_values:\n        for key in roman_keys:\n            if value >= roman_numerals[key]:\n                result += key\n                value -= roman_numerals[key]\n                break\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Eko", "final_solution": "def main():\n    import bisect\n\n    N, M = map(int, input().split())\n    trees = list(map(int, input().split()))\n\n    trees.sort(reverse=True)\n\n    low, high = 0, trees[0]\n    while low < high:\n        mid = (low + high + 1) // 2\n        total_wood = sum(max(0, tree - mid) for tree in trees)\n        if total_wood < M:\n            high = mid - 1\n        else:\n            low = mid\n\n    print(low)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    import bisect\n\n    N, M = map(int, input().split())\n    trees = list(map(int, input().split()))\n\n    trees.sort(reverse=True)\n\n    low, high = 0, trees[0]\n    while low < high:\n        mid = (low + high + 1) // 2\n        total_wood = sum(max(0, tree - mid) for tree in trees)\n        if total_wood < M:\n            high = mid - 1\n        else:\n            low = mid\n\n    print(low)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Font", "final_solution": "from itertools import combinations\nfrom collections import Counter\n\ndef main():\n    N = int(input())\n    words = [input() for _ in range(N)]\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    count = 0\n\n    for r in range(1, N + 1):\n        for combo in combinations(words, r):\n            sentence = ''.join(combo)\n            if set(alphabet).issubset(set(sentence)):\n                count += 1\n\n    print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "from itertools import combinations\nfrom collections import Counter\n\ndef main():\n    N = int(input())\n    words = [input() for _ in range(N)]\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    count = 0\n\n    for r in range(1, N + 1):\n        for combo in combinations(words, r):\n            sentence = ''.join(combo)\n            if set(alphabet).issubset(set(sentence)):\n                count += 1\n\n    print(count)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Toys", "final_solution": "def josephus(n, k):\n    if n == 1:\n        return 0\n    else:\n        return (josephus(n - 1, k) + k) % n\n\ndef main():\n    T, K = map(int, input().split())\n    print(josephus(T, K))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def josephus(n, k):\n    if n == 1:\n        return 0\n    else:\n        return (josephus(n - 1, k) + k) % n\n\ndef main():\n    T, K = map(int, input().split())\n    print(josephus(T, K))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Where to Live?", "final_solution": "import math\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        x_coords = []\n        y_coords = []\n        for _ in range(n):\n            x, y = map(int, input().split())\n            x_coords.append(x)\n            y_coords.append(y)\n        \n        avg_x = round(sum(x_coords) / n)\n        avg_y = round(sum(y_coords) / n)\n        \n        print(f\"{avg_x} {avg_y}\")\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import math\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        x_coords = []\n        y_coords = []\n        for _ in range(n):\n            x, y = map(int, input().split())\n            x_coords.append(x)\n            y_coords.append(y)\n        \n        avg_x = round(sum(x_coords) / n)\n        avg_y = round(sum(y_coords) / n)\n        \n        print(f\"{avg_x} {avg_y}\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Greeting Card", "final_solution": "import math\nfrom itertools import combinations\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef count_segments(points):\n    count = 0\n    for p1, p2 in combinations(points, 2):\n        if distance(p1, p2) == 2018:\n            count += 1\n    return count\n\ndef main():\n    n = int(input())\n    points = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        points.append((x, y))\n    print(count_segments(points))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import math\nfrom itertools import combinations\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef count_segments(points):\n    count = 0\n    for p1, p2 in combinations(points, 2):\n        if distance(p1, p2) == 2018:\n            count += 1\n    return count\n\ndef main():\n    n = int(input())\n    points = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        points.append((x, y))\n    print(count_segments(points))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Robert Hood", "final_solution": "import math\n\ndef distance(x1, y1, x2, y2):\n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\ndef longest_distance(shots):\n    max_distance = 0\n    for i in range(len(shots)):\n        for j in range(i + 1, len(shots)):\n            dist = distance(shots[i][0], shots[i][1], shots[j][0], shots[j][1])\n            max_distance = max(max_distance, dist)\n    return round(max_distance, 6)\n\ndef main():\n    C = int(input())\n    shots = []\n    for _ in range(C):\n        x, y = map(int, input().split())\n        shots.append((x, y))\n    if len(shots) < 2:\n        print(\"Disqualified\")\n    else:\n        print(longest_distance(shots))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import math\n\ndef distance(x1, y1, x2, y2):\n    return math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2)\n\ndef longest_distance(shots):\n    max_distance = 0\n    for i in range(len(shots)):\n        for j in range(i + 1, len(shots)):\n            dist = distance(shots[i][0], shots[i][1], shots[j][0], shots[j][1])\n            max_distance = max(max_distance, dist)\n    return max_distance\n\ndef main():\n    C = int(input())\n    shots = []\n    for _ in range(C):\n        x, y = map(int, input().split())\n        shots.append((x, y))\n    if len(shots) < 2:\n        print(\"Disqualified\")\n    else:\n        print(longest_distance(shots))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Perica", "final_solution": "import itertools\nimport math\n\ndef main():\n    MOD = 1000000007\n    N, K = map(int, input().split())\n    keys = list(map(int, input().split()))\n    keys.sort(reverse=True)\n    \n    total = 0\n    for combination in itertools.combinations(keys, K):\n        total += max(combination)\n        total %= MOD\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import itertools\nimport math\n\ndef main():\n    MOD = 1000000007\n    N, K = map(int, input().split())\n    keys = list(map(int, input().split()))\n    keys.sort(reverse=True)\n    \n    total = 0\n    for i in range(K, N + 1):\n        total += sum(keys[:i])\n        total %= MOD\n    \n    print(total)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Digbuild", "final_solution": "MOD = 10**9 + 7\n\ndef main():\n    n = int(input())\n\n    # Calculate the number of non-ugly torch arrangements\n    if n == 1:\n        print(5)\n    elif n == 2:\n        print(7)\n    else:\n        a, b, c = 5, 7, 10\n        for _ in range(3, n + 1):\n            a, b, c = b, c, (2 * b + 3 * a - 2) % MOD\n        print(c)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    MOD = 10**9 + 7\n    n = int(input())\n\n    # Initialize the base cases\n    dp = [0]*(n+1)\n    dp[0] = 1\n    dp[1] = 2\n\n    # Calculate the number of non-ugly torch arrangements\n    for i in range(2, n+1):\n        dp[i] = (dp[i-1] * 2 + dp[i-2]) % MOD\n\n    print(dp[n])\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Crane", "final_solution": "def main():\n    T = int(input())\n    for _ in range(T):\n        n = int(input())\n        crates = list(map(int, input().split()))\n        swaps = 0\n        moves = []\n        for i in range(n):\n            while crates[i] != i + 1:\n                j = crates.index(i + 1)\n                if j > i:\n                    crates[i:j+1] = crates[i:j+1][::-1]\n                    moves.append((i + 1, j + 1))\n                    swaps += 1\n        print(swaps)\n        for move in moves:\n            print(*move)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    T = int(input())\n    for _ in range(T):\n        n = int(input())\n        crates = list(map(int, input().split()))\n        swaps = 0\n        moves = []\n        for i in range(n // 2):\n            if crates[i] > crates[n - i - 1]:\n                j = i\n                while crates[j] != n - i:\n                    j += 1\n                moves.append((i + 1, j + 1))\n                crates[i:j + 1] = crates[i:j + 1][::-1]\n                swaps += 1\n            if crates[n - i - 1] > crates[i]:\n                j = n - i - 1\n                while crates[j] != i + 1:\n                    j -= 1\n                moves.append((j + 1, n - i))\n                crates[j:n - i] = crates[j:n - i][::-1]\n                swaps += 1\n        print(swaps)\n        for move in moves:\n            print(*move)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Movie Collection", "final_solution": "import sys\n\ndef main():\n    stdin = sys.stdin\n    stdout = sys.stdout\n    test_cases = stdin.readline().strip()\n    if test_cases:\n        test_cases = int(test_cases)\n        for _ in range(test_cases):\n            m, r = map(int, stdin.readline().split())\n            stack = list(range(1, m + 1))\n            result = []\n            for _ in range(r):\n                a = int(stdin.readline())\n                index = stack.index(a)\n                result.append(index)\n                stack.pop(index)\n                stack.insert(0, a)\n            stdout.write(' '.join(map(str, result)) + '\\n')\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import sys\n\ndef main():\n    test_cases = int(sys.stdin.readline())\n    for _ in range(test_cases):\n        m, r = map(int, sys.stdin.readline().split())\n        stack = list(range(1, m + 1))\n        result = []\n        for _ in range(r):\n            a = int(sys.stdin.readline())\n            index = stack.index(a)\n            result.append(index)\n            stack.pop(index)\n            stack.insert(0, a)\n        print(' '.join(map(str, result)))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Judo Championship", "final_solution": "def main():\n    n, m = map(int, input().split())\n    result = '01' * (m // 2) + '0' * (m % 2)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "from collections import defaultdict\n\ndef main():\n    n, m = map(int, input().split())\n    graph = defaultdict(list)\n    for _ in range(m):\n        u, v = map(int, input().split())\n        graph[u].append(v)\n        graph[v].append(u)\n\n    result = ''\n    for _ in range(m):\n        result += '0'\n\n    print(result)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Programming Tutors", "final_solution": "import numpy as np\nfrom scipy.optimize import linear_sum_assignment\n\ndef main():\n    N = int(input())\n    students = []\n    for _ in range(N):\n        students.append(list(map(int, input().split())))\n    tutors = []\n    for _ in range(N):\n        tutors.append(list(map(int, input().split())))\n\n    distances = [[0 for _ in range(N)] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            distances[i][j] = abs(students[i][0] - tutors[j][0]) + abs(students[i][1] - tutors[j][1])\n\n    row_ind, col_ind = linear_sum_assignment(distances)\n    max_distance = max([distances[row_ind[k]][col_ind[k]] for k in range(N)])\n\n    print(max_distance)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import numpy as np\nfrom scipy.optimize import linear_sum_assignment\n\ndef main():\n    N = int(input())\n    students = []\n    for _ in range(N):\n        students.append(list(map(int, input().split())))\n    tutors = []\n    for _ in range(N):\n        tutors.append(list(map(int, input().split())))\n\n    distances = np.zeros((N, N))\n    for i in range(N):\n        for j in range(N):\n            distances[i, j] = abs(students[i][0] - tutors[j][0]) + abs(students[i][1] - tutors[j][1])\n\n    row_ind, col_ind = linear_sum_assignment(distances)\n    max_distance = max(distances[row_ind, col_ind])\n\n    print(max_distance)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "King's Colors", "final_solution": "MOD = 1000000007\n\ndef main():\n    n, k = map(int, input().split())\n    edges = [int(input()) for _ in range(n - 1)]\n    dp = [0] * (k + 1)\n    dp[0] = 1\n    for _ in range(n):\n        ndp = [0] * (k + 1)\n        for i in range(1, k + 1):\n            ndp[i] = (dp[i] * (i - 1) + dp[i - 1] * i) % MOD\n        dp = ndp\n    print(dp[k])\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    MOD = 1000000007\n    n, k = map(int, input().split())\n    dp = [0] * (k + 1)\n    dp[0] = 1\n    for _ in range(n):\n        ndp = [0] * (k + 1)\n        for i in range(1, k + 1):\n            ndp[i] = (dp[i] * (i - 1) + dp[i - 1] * i) % MOD\n        dp = ndp\n    print(dp[k])\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Digit Division", "final_solution": "MOD = 10**9 + 7\n\ndef main():\n    n, m = map(int, input().split())\n    s = input()\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    num = 0\n    for i in range(n):\n        num = (num * 10 + int(s[i])) % m\n        if num == 0:\n            dp[i + 1] = (dp[i + 1] + dp[i]) % MOD\n    print(dp[-1])\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    MOD = 10**9 + 7\n    n, m = map(int, input().split())\n    s = input()\n    dp = [0] * (n + 1)\n    dp[0] = 1\n    for i in range(n):\n        num = 0\n        for j in range(i, -1, -1):\n            num = num * 10 + int(s[j])\n            if num % m == 0:\n                dp[i + 1] += dp[j]\n                dp[i + 1] %= MOD\n    print(dp[-1])\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Contest Advancement", "final_solution": "from collections import defaultdict\n\ndef main():\n    n, k, c = map(int, input().split())\n    teams = []\n    for _ in range(n):\n        t, s = map(int, input().split())\n        teams.append((t, s))\n    \n    teams.sort(reverse=True)\n    school_count = defaultdict(int)\n    qualified_teams = []\n    \n    for t, s in teams:\n        if school_count[s] < c:\n            qualified_teams.append(t)\n            school_count[s] += 1\n        if len(qualified_teams) == k:\n            break\n    \n    if len(qualified_teams) < k:\n        teams.sort(key=lambda x: x[0], reverse=True)\n        for t, s in teams:\n            if t not in qualified_teams:\n                qualified_teams.append(t)\n                if len(qualified_teams) == k:\n                    break\n    \n    for t in sorted(qualified_teams):\n        print(t)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "from collections import defaultdict\n\ndef main():\n    n, k, c = map(int, input().split())\n    teams = []\n    for _ in range(n):\n        t, s = map(int, input().split())\n        teams.append((t, s))\n    \n    teams.sort(reverse=True)\n    school_count = defaultdict(int)\n    qualified_teams = []\n    \n    for t, s in teams:\n        if school_count[s] < c:\n            qualified_teams.append(t)\n            school_count[s] += 1\n        if len(qualified_teams) == k:\n            break\n    \n    while len(qualified_teams) < k:\n        for t, s in teams:\n            if t not in qualified_teams:\n                qualified_teams.append(t)\n                break\n    \n    for t in qualified_teams:\n        print(t)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Swap Space", "final_solution": "import heapq\n\ndef main():\n    n = int(input())\n    drives = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        drives.append((a, b))\n\n    drives.sort(key=lambda x: (x[0], -x[1]), reverse=True)\n\n    pq = []\n    extra_capacity = 0\n    for old, new in drives:\n        if old > new:\n            heapq.heappush(pq, old - new)\n        else:\n            while pq and new < old:\n                new += heapq.heappop(pq)\n            if new < old:\n                extra_capacity += old - new\n\n    print(max(extra_capacity, 0))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import heapq\n\ndef main():\n    n = int(input())\n    old_capacities = []\n    new_capacities = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        old_capacities.append(a)\n        new_capacities.append(b)\n\n    old_capacities.sort(reverse=True)\n    new_capacities.sort(reverse=True)\n\n    extra_capacity = 0\n    for old, new in zip(old_capacities, new_capacities):\n        if old > new:\n            extra_capacity += old - new\n\n    pq = []\n    for old, new in zip(old_capacities, new_capacities):\n        if old < new:\n            heapq.heappush(pq, new - old)\n\n    while pq:\n        extra_capacity -= heapq.heappop(pq)\n        if extra_capacity < 0:\n            extra_capacity = 0\n\n    print(extra_capacity)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Road To Savings", "final_solution": "import heapq\n\ndef main():\n    n, m, a, b = map(int, input().split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        i1, i2, l = map(int, input().split())\n        graph[i1].append((i2, l))\n        graph[i2].append((i1, l))\n\n    def dijkstra(start):\n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n        pq = [(0, start)]\n        while pq:\n            d, u = heapq.heappop(pq)\n            if d > dist[u]:\n                continue\n            for v, l in graph[u]:\n                if dist[u] + l < dist[v]:\n                    dist[v] = dist[u] + l\n                    heapq.heappush(pq, (dist[v], v))\n        return dist\n\n    dist_a = dijkstra(a)\n    dist_b = dijkstra(b)\n    total_length = sum(l for i in range(1, n + 1) for _, l in graph[i])\n    paved_length = min(dist_a[b], dist_b[a])\n    unpaved_length = 0\n    for i in range(1, n + 1):\n        for j, l in graph[i]:\n            if dist_a[i] + l == dist_a[j] or dist_b[i] + l == dist_b[j]:\n                continue\n            unpaved_length += l\n    print(unpaved_length)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import heapq\n\ndef main():\n    n, m, a, b = map(int, input().split())\n    graph = [[] for _ in range(n + 1)]\n    for _ in range(m):\n        i1, i2, l = map(int, input().split())\n        graph[i1].append((i2, l))\n        graph[i2].append((i1, l))\n\n    def dijkstra(start):\n        dist = [float('inf')] * (n + 1)\n        dist[start] = 0\n        pq = [(0, start)]\n        while pq:\n            d, u = heapq.heappop(pq)\n            if d > dist[u]:\n                continue\n            for v, l in graph[u]:\n                if dist[u] + l < dist[v]:\n                    dist[v] = dist[u] + l\n                    heapq.heappush(pq, (dist[v], v))\n        return dist\n\n    dist_a = dijkstra(a)\n    dist_b = dijkstra(b)\n    total_length = sum(l for i in range(1, n + 1) for _, l in graph[i])\n    paved_length = dist_a[b]\n    print(total_length - paved_length)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Closest Pair (Uniform)", "final_solution": "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef brute_force_closest_pair(points):\n    if len(points) < 2:\n        return None\n    min_dist = float('inf')\n    closest_pair = None\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            dist = distance(points[i], points[j])\n            if dist < min_dist:\n                min_dist = dist\n                closest_pair = tuple(sorted([points[i], points[j]]))\n    return closest_pair\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        points = []\n        for _ in range(n):\n            x, y = map(float, input().split())\n            points.append((x, y))\n        closest_pair = brute_force_closest_pair(points)\n        if closest_pair:\n            print(f\"{closest_pair[0][0]:.2f} {closest_pair[0][1]:.2f} {closest_pair[1][0]:.2f} {closest_pair[1][1]:.2f}\")\n        else:\n            print('')\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef brute_force_closest_pair(points):\n    min_dist = float('inf')\n    closest_pair = None\n    for i in range(len(points)):\n        for j in range(i + 1, len(points)):\n            dist = distance(points[i], points[j])\n            if dist < min_dist:\n                min_dist = dist\n                closest_pair = (points[i], points[j])\n    return closest_pair\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        points = []\n        for _ in range(n):\n            x, y = map(float, input().split())\n            points.append((x, y))\n        closest_pair = brute_force_closest_pair(points)\n        print(f\"{closest_pair[0][0]:.2f} {closest_pair[0][1]:.2f} {closest_pair[1][0]:.2f} {closest_pair[1][1]:.2f}\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Lost in Translation", "final_solution": "import heapq\n\ndef main():\n    n, m = map(int, input().split())\n    target_languages = input().split()\n    graph = {lang: {} for lang in target_languages + ['English']}\n    for _ in range(m):\n        l1, l2, c = input().split()\n        c = int(c)\n        graph[l1][l2] = c\n        graph[l2][l1] = c\n\n    distances = {lang: float('inf') for lang in target_languages}\n    distances['English'] = 0\n    pq = [('English', 0)]\n\n    while pq:\n        lang, cost = heapq.heappop(pq)\n        if cost > distances[lang]:\n            continue\n        for neighbor, neighbor_cost in graph[lang].items():\n            if neighbor not in target_languages and neighbor != 'English':\n                continue\n            new_cost = cost + neighbor_cost\n            if new_cost < distances[neighbor]:\n                distances[neighbor] = new_cost\n                heapq.heappush(pq, (neighbor, new_cost))\n\n    total_cost = 0\n    for dist in distances.values():\n        if dist == float('inf'):\n            print(\"Impossible\")\n            return\n        total_cost += dist\n    print(total_cost)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import heapq\n\ndef main():\n    n, m = map(int, input().split())\n    target_languages = input().split()\n    graph = {lang: {} for lang in target_languages + ['English']}\n    for _ in range(m):\n        l1, l2, c = input().split()\n        c = int(c)\n        graph[l1][l2] = c\n        graph[l2][l1] = c\n\n    distances = {lang: float('inf') for lang in target_languages}\n    distances['English'] = 0\n    pq = [('English', 0)]\n\n    while pq:\n        lang, cost = heapq.heappop(pq)\n        if cost > distances[lang]:\n            continue\n        for neighbor, neighbor_cost in graph[lang].items():\n            new_cost = cost + neighbor_cost\n            if new_cost < distances[neighbor]:\n                distances[neighbor] = new_cost\n                heapq.heappush(pq, (neighbor, new_cost))\n\n    total_cost = sum(distances.values())\n    if total_cost == float('inf'):\n        print(\"Impossible\")\n    else:\n        print(total_cost)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Six Degrees", "final_solution": "from collections import deque\n\ndef bfs(graph, start, max_distance):\n    visited = set()\n    queue = deque([(start, 0)])\n    while queue:\n        node, distance = queue.popleft()\n        if node not in visited:\n            visited.add(node)\n            if distance > max_distance:\n                return False\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    queue.append((neighbor, distance + 1))\n    return True\n\ndef is_plan_allowed(graph):\n    devices_to_disconnect = 0\n    for node in graph:\n        can_reach_all = True\n        for other_node in graph:\n            if other_node != node:\n                if not bfs(graph, node, 5):\n                    can_reach_all = False\n                    break\n        if not can_reach_all:\n            devices_to_disconnect += 1\n    return devices_to_disconnect / len(graph) <= 0.05\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        M = int(input())\n        graph = {}\n        for _ in range(M):\n            node1, node2 = input().split()\n            if node1 not in graph:\n                graph[node1] = []\n            if node2 not in graph:\n                graph[node2] = []\n            graph[node1].append(node2)\n            graph[node2].append(node1)\n        if is_plan_allowed(graph):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "from collections import deque\n\ndef bfs(graph, start, max_distance):\n    visited = set()\n    queue = deque([(start, 0)])\n    while queue:\n        node, distance = queue.popleft()\n        if node not in visited:\n            visited.add(node)\n            if distance > max_distance:\n                return False\n            for neighbor in graph[node]:\n                if neighbor not in visited:\n                    queue.append((neighbor, distance + 1))\n    return True\n\ndef is_plan_allowed(graph, max_devices):\n    devices_to_disconnect = 0\n    for node in graph:\n        if not bfs(graph, node, 5):\n            devices_to_disconnect += 1\n    return devices_to_disconnect / len(graph) <= 0.05\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        M = int(input())\n        graph = {}\n        for _ in range(M):\n            node1, node2 = input().split()\n            if node1 not in graph:\n                graph[node1] = []\n            if node2 not in graph:\n                graph[node2] = []\n            graph[node1].append(node2)\n            graph[node2].append(node1)\n        if is_plan_allowed(graph, M):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Screamers in the Storm", "final_solution": "def count_dunes(K, N):\n    MOD = 10**9 + 7\n    def multiply(a, b):\n        c = [[0]*K for _ in range(K)]\n        for i in range(K):\n            for j in range(K):\n                for k in range(K):\n                    c[i][j] += a[i][k] * b[k][j]\n                    c[i][j] %= MOD\n        return c\n\n    def matrix_power(matrix, n):\n        result = [[1 if i == j else 0 for j in range(K)] for i in range(K)]\n        while n > 0:\n            if n % 2 == 1:\n                result = multiply(result, matrix)\n            matrix = multiply(matrix, matrix)\n            n //= 2\n        return result\n\n    transition_matrix = [[0]*K for _ in range(K)]\n    for i in range(1, K+1):\n        for j in range(1, K+1):\n            if gcd(i, j) == 1:\n                transition_matrix[i-1][j-1] = 1\n                transition_matrix[i-1][j-1] %= MOD\n\n    result_matrix = matrix_power(transition_matrix, N-1)\n    return sum(result_matrix[0]) % MOD\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef main():\n    K, N = map(int, input().split())\n    print(count_dunes(K, N))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\ndef count_dunes(K, N):\n    MOD = 10**9 + 7\n    dp = [0]*(K+1)\n    dp[0] = 1\n    for _ in range(N):\n        new_dp = [0]*(K+1)\n        for i in range(1, K+1):\n            for j in range(1, i):\n                if gcd(i, j) == 1:\n                    new_dp[i] += dp[j]\n                    new_dp[i] %= MOD\n        dp = new_dp\n    return sum(dp[1:]) % MOD\n\ndef main():\n    K, N = map(int, input().split())\n    print(count_dunes(K, N))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Ferry Loading III", "final_solution": "from collections import deque\nfrom typing import Deque, List, Tuple\n\ndef main():\n    test_cases = int(input())\n    for _ in range(test_cases):\n        n, t, m = map(int, input().split())\n        cars: List[Tuple[int, str]] = [tuple([int(x[0]), x[1]]) for x in [input().split() for _ in range(m)]]\n        cars.sort()\n        ferry_time = 0\n        ferry_bank = \"left\"\n        ferry_cars: Deque[Tuple[int, str]] = deque()\n        waiting_cars: Deque[Tuple[int, str]] = deque(cars)\n        result = []\n\n        while waiting_cars or ferry_cars:\n            if ferry_bank == \"left\":\n                while waiting_cars and len(ferry_cars) < n:\n                    car_time, car_bank = waiting_cars[0]\n                    if car_bank == \"left\":\n                        ferry_cars.append(waiting_cars.popleft())\n                    else:\n                        break\n                if ferry_cars:\n                    ferry_time += t\n                    ferry_bank = \"right\"\n                    while ferry_cars:\n                        car_time, _ = ferry_cars.popleft()\n                        result.append(ferry_time + car_time)\n                else:\n                    if waiting_cars:\n                        ferry_time = max(ferry_time, waiting_cars[0][0])\n                    else:\n                        break\n            else:\n                while waiting_cars and len(ferry_cars) < n:\n                    car_time, car_bank = waiting_cars[0]\n                    if car_bank == \"right\":\n                        ferry_cars.append(waiting_cars.popleft())\n                    else:\n                        break\n                if ferry_cars:\n                    ferry_time += t\n                    ferry_bank = \"left\"\n                    while ferry_cars:\n                        car_time, _ = ferry_cars.popleft()\n                        result.append(ferry_time + car_time)\n                else:\n                    if waiting_cars:\n                        ferry_time = max(ferry_time, waiting_cars[0][0])\n                    else:\n                        break\n\n        for time in result:\n            print(time)\n        print()\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "from collections import deque\nfrom typing import Deque, List, Tuple\n\ndef main():\n    test_cases = int(input())\n    for _ in range(test_cases):\n        n, t, m = map(int, input().split())\n        cars: List[Tuple[int, str]] = [tuple(input().split()) for _ in range(m)]\n        ferry_time = 0\n        ferry_bank = \"left\"\n        ferry_cars: Deque[Tuple[int, str]] = deque()\n        waiting_cars: Deque[Tuple[int, str]] = deque(cars)\n        result = []\n        \n        while waiting_cars or ferry_cars:\n            while waiting_cars and waiting_cars[0][1] == ferry_bank:\n                if len(ferry_cars) < n:\n                    car_time, _ = waiting_cars.popleft()\n                    ferry_cars.append((car_time, ferry_bank))\n                else:\n                    break\n            \n            if ferry_cars:\n                ferry_time += t\n                if ferry_bank == \"left\":\n                    ferry_bank = \"right\"\n                else:\n                    ferry_bank = \"left\"\n                while ferry_cars:\n                    car_time, _ = ferry_cars.popleft()\n                    result.append(ferry_time + car_time)\n            else:\n                if waiting_cars:\n                    car_time, _ = waiting_cars[0]\n                    ferry_time = max(ferry_time, car_time)\n                else:\n                    break\n        \n        for time in result:\n            print(time)\n        print()\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "A Classy Problem", "final_solution": "import re\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        n = int(input())\n        people = []\n        for _ in range(n):\n            name, class_str = input().split(': ')\n            class_str = class_str.replace(' class', '')\n            class_levels = re.split('-| ', class_str)\n            people.append((name, class_levels))\n        people.sort(key=lambda x: ([-1 if level == 'upper' else 0 if level == 'middle' else 1 for level in x[1]], x[0]))\n        for name, _ in people:\n            print(name)\n        print('=' * 30)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import re\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        n = int(input())\n        people = []\n        for _ in range(n):\n            name, class_str = input().split(': ')\n            class_str = class_str.replace(' class', '')\n            class_levels = re.split('-| ', class_str)\n            people.append((name, class_levels))\n        people.sort(key=lambda x: (-x[1].count('upper'), x[1].count('middle'), x[1].count('lower'), x[0]))\n        for name, _ in people:\n            print(name)\n        print('=' * 30)\n\nif __name__ == \"__main__\":\n    main()\n"}
