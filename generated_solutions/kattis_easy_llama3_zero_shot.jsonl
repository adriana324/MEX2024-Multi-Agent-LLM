{"task_id": "Autori", "final_solution": "\ndef main():\n    full_name = input()\n    short_name = ''.join([word[0].upper() for word in full_name.split('-')])\n    print(short_name)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "\ndef main():\n    full_name = input()\n    short_name = ''.join([word[0].upper() for word in full_name.split('-')])\n    print(short_name)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Knight Packing", "final_solution": "def main():\n    N = int(input())\n    if (N - 1) % 4 == 0 or (N - 3) % 4 == 0:\n        print(\"first\")\n    else:\n        print(\"second\")\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    N = int(input())\n    if (N + 1) % 4 == 0:\n        print(\"first\")\n    else:\n        print(\"second\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Two-sum", "final_solution": "import sys\n\ndef main():\n    while True:\n        try:\n            a, b = map(int, input().split())\n            if 0 <= a <= 1000 and 0 <= b <= 1000:\n                print(a + b)\n                break\n            else:\n                print(\"Invalid input. Please enter two integers between 0 and 1000.\")\n        except ValueError:\n            print(\"Invalid input. Please enter two integers.\")\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    a, b = map(int, input().split())\n    print(a + b)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Oddities", "final_solution": "import sys\n\ndef main():\n    inputs = []\n    n = int(input())\n    for _ in range(n):\n        inputs.append(int(input()))\n    for x in inputs:\n        if x % 2 == 0:\n            print(f\"{x} is even\")\n        else:\n            print(f\"{x} is odd\")\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    n = int(input())\n    for _ in range(n):\n        x = int(input())\n        if x % 2 == 0:\n            print(f\"{x} is even\")\n        else:\n            print(f\"{x} is odd\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Grass Seed Inc.", "final_solution": "import math\n\ndef calculate_lawn_cost():\n    cost_per_sqm = float(input())\n    num_lawns = int(input())\n    total_cost = 0\n    for _ in range(num_lawns):\n        width, length = map(float, input().split())\n        lawn_area = width * length\n        total_cost += lawn_area * cost_per_sqm\n    return total_cost\n\ndef main():\n    total_cost = calculate_lawn_cost()\n    print(\"{:.10f}\".format(total_cost))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import math\n\ndef calculate_lawn_cost(cost_per_sqm, num_lawns):\n    total_cost = 0\n    for _ in range(num_lawns):\n        width, length = map(float, input().split())\n        lawn_area = width * length\n        total_cost += lawn_area * cost_per_sqm\n    return total_cost\n\ndef main():\n    cost_per_sqm = float(input())\n    num_lawns = int(input())\n    total_cost = calculate_lawn_cost(cost_per_sqm, num_lawns)\n    print(f\"{total_cost:.10f}\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Decimal deletion", "final_solution": "import math\n\ndef main():\n    N = float(input())\n    print(round(N + 1e-9))  # Add a small value to handle halfway cases correctly\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "\nimport math\n\ndef main():\n    N = float(input())\n    print(round(N))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Cold-puter Science", "final_solution": "def main():\n    n = int(input())\n    temperatures = list(map(int, input().split()))\n    count = sum(1 for temp in temperatures if temp < 0)\n    print(count)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    n = int(input())\n    temperatures = list(map(int, input().split()))\n    count = sum(1 for temp in temperatures if temp < 0)\n    print(count)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Greetings!", "final_solution": "def main():\n    s = input()\n    e_count = s.count('e')\n    response = 'h' + 'e' * (2 * e_count) + 'y'\n    print(response)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    s = input()\n    e_count = s.count('e')\n    response = 'h' + 'e' * (2 * e_count) + 'y'\n    print(response)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Aaah!", "final_solution": "\ndef main():\n    jon_marius_aah = input()\n    doctor_aah = input()\n\n    if len(jon_marius_aah[:-1]) >= len(doctor_aah[:-1]):\n        print(\"go\")\n    else:\n        print(\"no\")\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "\ndef main():\n    jon_marius_aah = input()\n    doctor_aah = input()\n\n    if len(jon_marius_aah[:-1]) >= len(doctor_aah[:-1]):\n        print(\"go\")\n    else:\n        print(\"no\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "GCD", "final_solution": "\ndef gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef main():\n    a, b = map(int, input().split())\n    print(gcd(a, b))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "\ndef gcd(a, b):\n    while b != 0:\n        a, b = b, a % b\n    return a\n\ndef main():\n    a, b = map(int, input().split())\n    print(gcd(a, b))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Symmetric Order", "final_solution": "import sys\n\ndef main():\n    set_number = 1\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        names = [input() for _ in range(n)]\n        names.sort(key=len)\n        result = []\n        for i in range(n // 2):\n            result.append(names[i])\n            result.append(names[n - i - 1])\n        if n % 2 == 1:\n            result.append(names[n // 2])\n        print(f\"SET {set_number}\")\n        for name in result:\n            print(name)\n        print()\n        set_number += 1\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    set_number = 1\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        names = [input() for _ in range(n)]\n        half = n // 2\n        top_half = names[:half]\n        bottom_half = names[half:][::-1]\n        print(f\"SET {set_number}\")\n        for name in top_half + bottom_half:\n            print(name)\n        print()\n        set_number += 1\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Secure Doors", "final_solution": "import sys\n\ndef main():\n    n = int(input())\n    log = {}\n    for _ in range(n):\n        action, name = input().split()\n        if action == 'entry':\n            if name in log and log[name]:\n                print(f\"{name} entered (ANOMALY)\")\n            else:\n                print(f\"{name} entered\")\n            log[name] = True\n        elif action == 'exit':\n            if name not in log or not log.get(name, False):\n                print(f\"{name} exited (ANOMALY)\")\n            else:\n                print(f\"{name} exited\")\n            log[name] = False\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    n = int(input())\n    log = {}\n    for _ in range(n):\n        action, name = input().split()\n        if action == 'entry':\n            if name in log and log[name]:\n                print(f\"{name} entered (ANOMALY)\")\n            else:\n                print(f\"{name} entered\")\n            log[name] = True\n        elif action == 'exit':\n            if name not in log or not log[name]:\n                print(f\"{name} exited (ANOMALY)\")\n            else:\n                print(f\"{name} exited\")\n            log[name] = False\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Code to Save Lives", "final_solution": "import sys\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        num1 = list(map(int, input().split()))\n        num2 = list(map(int, input().split()))\n        result = []\n        carry = 0\n        max_len = max(len(num1), len(num2))\n        for i in range(max_len):\n            n1 = num1[-1 - i] if i < len(num1) else 0\n            n2 = num2[-1 - i] if i < len(num2) else 0\n            temp = n1 + n2 + carry\n            result.append(str(temp % 10))\n            carry = temp // 10\n        if carry:\n            result.append(str(carry))\n        print(' '.join(result[::-1]))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    t = int(input())\n    for _ in range(t):\n        num1 = list(map(int, input().split()))\n        num2 = list(map(int, input().split()))\n        result = []\n        carry = 0\n        max_len = max(len(num1), len(num2))\n        for i in range(max_len):\n            n1 = num1[i] if i < len(num1) else 0\n            n2 = num2[i] if i < len(num2) else 0\n            temp = n1 + n2 + carry\n            result.append(str(temp % 10))\n            carry = temp // 10\n        if carry:\n            result.append(str(carry))\n        print(' '.join(result[::-1]))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Half a Cookie", "final_solution": "import math\nimport sys\n\ndef main():\n    for line in sys.stdin:\n        r, x, y = map(float, line.split())\n        if x**2 + y**2 > r**2:\n            print(\"miss\")\n        else:\n            if x == 0:\n                theta = 0 if y > 0 else math.pi\n            else:\n                theta = math.acos(x / math.sqrt(x**2 + y**2))\n            area1 = 0.5 * r**2 * theta\n            area2 = math.pi * r**2 - area1\n            if area1 > area2:\n                print(f\"{area1:.6f} {area2:.6f}\")\n            else:\n                print(f\"{area2:.6f} {area1:.6f}\")\n        print()  # Add a newline character after each test case\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import math\n\ndef main():\n    while True:\n        try:\n            r, x, y = map(float, input().split())\n            if x**2 + y**2 > r**2:\n                print(\"miss\")\n            else:\n                theta = math.acos(x / math.sqrt(x**2 + y**2))\n                area1 = 0.5 * r**2 * theta\n                area2 = math.pi * r**2 - area1\n                if area1 > area2:\n                    print(f\"{area1:.6f} {area2:.6f}\")\n                else:\n                    print(f\"{area2:.6f} {area1:.6f}\")\n        except EOFError:\n            break\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Just a Minute", "final_solution": "def main():\n    N = int(input())\n    total_wait_time = 0\n    total_display_time = 0\n\n    for _ in range(N):\n        M, S = map(int, input().split())\n        total_wait_time += S / 60\n        total_display_time += M\n\n    if total_display_time == 0:\n        avg_SL_minute = 0\n    else:\n        avg_SL_minute = total_wait_time / total_display_time\n\n    if avg_SL_minute <= 1:\n        print('measurement error')\n    else:\n        print('{:.8f}'.format(avg_SL_minute))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    N = int(input())\n    total_wait_time = 0\n    total_display_time = 0\n\n    for _ in range(N):\n        M, S = map(int, input().split())\n        total_wait_time += S\n        total_display_time += M * 60\n\n    avg_SL_minute = total_wait_time / total_display_time * 60\n\n    if avg_SL_minute <= 1:\n        print('measurement error')\n    else:\n        print(avg_SL_minute)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Bacon, Eggs, and Spam", "final_solution": "from collections import defaultdict\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        orders = defaultdict(list)\n        for _ in range(n):\n            customer, *items = input().split()\n            for item in items:\n                orders[item].append(customer)\n        for item in sorted(orders.keys()):\n            print(f\"{item} {' '.join(sorted(orders[item]))}\")\n        print()  # Print a newline character after each day's report\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "from collections import defaultdict\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        orders = defaultdict(list)\n        for _ in range(n):\n            customer, *items = input().split()\n            for item in items:\n                orders[item].append(customer)\n        for item in sorted(orders.keys()):\n            print(f\"{item} {' '.join(sorted(orders[item]))}\")\n        print()\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Quite a Problem", "final_solution": "import sys\n\ndef main():\n    for line in sys.stdin:\n        if 'problem' in line.lower():\n            print('yes')\n        else:\n            print('no')\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "\ndef main():\n    while True:\n        try:\n            line = input()\n            if 'problem' in line.lower():\n                print('yes')\n            else:\n                print('no')\n        except EOFError:\n            break\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Card Trick", "final_solution": "import sys\n\ndef josephus_permutation(n):\n    result = [0] * n\n    pos = 0\n    for i in range(1, n + 1):\n        pos = (pos + i - 1) % i\n        result[pos] = i\n    return ' '.join(str(x) for x in result)\n\ndef main():\n    input_list = sys.stdin.readlines()\n    if input_list:\n        t = int(input_list[0])\n        for i in range(t):\n            n = int(input_list[i + 1].strip())\n            print(josephus_permutation(n))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def josephus_permutation(n):\n    result = [0] * n\n    pos = 0\n    for i in range(1, n + 1):\n        pos = (pos + i - 1) % i\n        result[pos] = i\n    return ' '.join(str(x) for x in result)\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        n = int(input())\n        print(josephus_permutation(n))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Touchscreen Keyboard", "final_solution": "def distance(word1, word2):\n    keyboard = ['qwertyuiop', 'asdfghjkl', 'zxcvbnm']\n    dist = 0\n    for c1, c2 in zip(word1, word2):\n        for i, row in enumerate(keyboard):\n            if c1 in row:\n                x1, y1 = row.index(c1), i\n            if c2 in row:\n                x2, y2 = row.index(c2), i\n        dist += abs(x1 - x2) + abs(y1 - y2)\n    return dist\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        word, l = input().split()\n        l = int(l)\n        words = [input() for _ in range(l)]\n        words.sort(key=lambda x: (distance(word, x), x))  \n        for w in words:\n            print(f\"{w} {distance(word, w)}\")\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def distance(word1, word2):\n    keyboard = ['qwertyuiop', 'asdfghjkl', 'zxcvbnm']\n    dist = 0\n    for c1, c2 in zip(word1, word2):\n        for row in keyboard:\n            if c1 in row:\n                x1, y1 = row.index(c1), keyboard.index(row)\n            if c2 in row:\n                x2, y2 = row.index(c2), keyboard.index(row)\n        dist += abs(x1 - x2) + abs(y1 - y2)\n    return dist\n\ndef main():\n    t = int(input())\n    for _ in range(t):\n        word, l = input().split()\n        l = int(l)\n        words = [input() for _ in range(l)]\n        words.sort(key=lambda x: (distance(word, x), x))\n        for w in words:\n            print(f\"{w} {distance(word, w)}\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Doorman", "final_solution": "import sys\n\ndef main():\n    X = int(input())\n    queue = input()\n\n    women = 0\n    men = 0\n    max_people = 0\n\n    for person in queue:\n        if person == 'W':\n            women += 1\n        else:\n            men += 1\n\n        if abs(women - men) <= X:\n            max_people += 1\n        else:\n            break\n\n    print(max_people)\n\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    X = int(input())\n    queue = input()\n\n    women = 0\n    men = 0\n    max_people = 0\n\n    for person in queue:\n        if person == 'W':\n            women += 1\n        else:\n            men += 1\n\n        if abs(women - men) > X:\n            break\n\n        max_people += 1\n\n    print(max_people)\n\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Above Average", "final_solution": "import sys\n\ndef main():\n    C = int(input())\n    for _ in range(C):\n        N = int(input())\n        grades = list(map(int, input().split()))\n        avg = sum(grades) / N\n        above_avg = sum(1 for grade in grades if grade > avg)\n        percentage = (above_avg / N) * 100\n        print(\"{:.3f}%\".format(percentage))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import sys\n\ndef main():\n    C = int(sys.stdin.readline())\n    for _ in range(C):\n        N = int(sys.stdin.readline())\n        grades = list(map(int, sys.stdin.readline().split()))\n        avg = sum(grades) / N\n        above_avg = sum(1 for grade in grades if grade > avg)\n        percentage = (above_avg / N) * 100\n        print(\"{:.3f}%\".format(percentage))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Bishops", "final_solution": "import sys\n\ndef main():\n    for line in sys.stdin:\n        n = int(line.strip())\n        max_bishops = (n * n + 1) // 2\n        print(max_bishops)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "\ndef main():\n    with open('input.txt', 'r') as f:\n        for line in f:\n            n = int(line.strip())\n            max_bishops = (n * n + 1) // 2\n            print(max_bishops)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Simon Says", "final_solution": "import sys\n\ndef main():\n    T = int(input())\n    for _ in range(T):\n        command = input().split()\n        if command[0] == \"simon\" and command[1] == \"says\":\n            print(\" \".join(command[2:]))\n        else:\n            pass  # Do nothing if the command doesn't start with \"simon says\"\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "\ndef main():\n    T = int(input())\n    for _ in range(T):\n        command = input().split()\n        if command[0] == \"simon\" and command[1] == \"says\":\n            print(\" \".join(command[2:]))\n        else:\n            print()\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Three Powers", "final_solution": "import itertools\n\ndef generate_powers_of_three():\n    powers = []\n    i = 0\n    while True:\n        power = 3**i\n        if power > 10**18:  # assuming the maximum value of n is 10**18\n            break\n        powers.append(power)\n        i += 1\n    return powers\n\ndef generate_subsets(powers):\n    for r in range(len(powers) + 1):\n        for combination in itertools.combinations(powers, r):\n            yield set(combination)\n\ndef main():\n    powers = generate_powers_of_three()\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        subsets = list(generate_subsets(powers))\n        sorted_subsets = sorted(subsets, key=sum)\n        print(\"{\" + \", \".join(map(str, sorted(list(sorted_subsets[n-1])))) + \"}\")\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import itertools\n\ndef generate_powers_of_three(n):\n    powers = [3**i for i in range(n)]\n    return powers\n\ndef generate_subsets(powers):\n    subsets = []\n    for r in range(len(powers) + 1):\n        subsets.extend(itertools.combinations(powers, r))\n    return subsets\n\ndef sum_of_subsets(subsets):\n    sums = {}\n    for i, subset in enumerate(subsets):\n        sums[i] = sum(subset)\n    return sums\n\ndef nth_subset(sums, n):\n    sorted_sums = sorted(sums.items(), key=lambda x: x[1])\n    return sorted_sums[n-1][0]\n\ndef main():\n    powers = generate_powers_of_three(20)  # generate powers of 3 up to 20\n    subsets = generate_subsets(powers)\n    sums = sum_of_subsets(subsets)\n\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        idx = nth_subset(sums, n)\n        subset = subsets[idx]\n        print(\"{\" + \", \".join(map(str, subset)) + \"}\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Disc District", "final_solution": "import math\n\ndef main():\n    r = int(input())\n    min_distance = float('inf')\n    closest_point = None\n    for x in range(r + 1, r * 2 + 1):\n        y = math.ceil(math.sqrt(r**2 - x**2))\n        distance = math.sqrt(x**2 + y**2)\n        if distance > r and distance < min_distance:\n            min_distance = distance\n            closest_point = (x, y)\n    print(closest_point[0], closest_point[1])\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import math\n\ndef main():\n    r = int(input())\n    x = math.ceil(r)\n    y = 1\n    while True:\n        if math.sqrt(x**2 + y**2) > r:\n            break\n        y += 1\n    print(x, y)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Laptop Stickers", "final_solution": "def main():\n    L, H, K = map(int, input().split())\n    laptop = [['_' for _ in range(L)] for _ in range(H)]\n    \n    for i in range(K):\n        l, h, a, b = map(int, input().split())\n        sticker_char = chr(ord('a') + i)\n        for j in range(h):\n            for k in range(l):\n                if 0 <= a + k < L and 0 <= b + j < H:\n                    laptop[b + j][a + k] = sticker_char\n    \n    for row in laptop:\n        print(''.join(row))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    L, H, K = map(int, input().split())\n    laptop = [['_' for _ in range(L)] for _ in range(H)]\n    \n    for i in range(K):\n        l, h, a, b = map(int, input().split())\n        sticker_char = chr(ord('a') + i)\n        for j in range(h):\n            for k in range(l):\n                if 0 <= a + k < L and 0 <= b + j < H:\n                    laptop[b + j][a + k] = sticker_char\n    \n    for row in laptop:\n        print(''.join(row))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Parent Gap", "final_solution": "import calendar\nimport datetime\n\ndef is_leap_year(year):\n    if year % 4 != 0:\n        return False\n    elif year % 100 != 0:\n        return True\n    elif year % 400 != 0:\n        return False\n    else:\n        return True\n\ndef get_mothers_day(year):\n    may_cal = calendar.monthcalendar(year, 5)\n    for week in may_cal:\n        if week[6] != 0 and week[6] >= 8:\n            return week[6]\n    return None\n\ndef get_fathers_day(year):\n    june_cal = calendar.monthcalendar(year, 6)\n    for i, week in enumerate(june_cal):\n        if week[6] != 0 and i >= 2:\n            return week[6]\n    return None\n\ndef get_parent_gap(year):\n    mothers_day = get_mothers_day(year)\n    fathers_day = get_fathers_day(year)\n    mothers_date = datetime.datetime(year, 5, mothers_day)\n    fathers_date = datetime.datetime(year, 6, fathers_day)\n    parent_gap = (fathers_date - mothers_date).days // 7\n    if parent_gap == 5:\n        return \"5 weeks\"\n    else:\n        return \"6 weeks\"\n\ndef main():\n    year = int(input())\n    print(get_parent_gap(year))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import calendar\nimport datetime\n\ndef is_leap_year(year):\n    if year % 4 != 0:\n        return False\n    elif year % 100 != 0:\n        return True\n    elif year % 400 != 0:\n        return False\n    else:\n        return True\n\ndef get_mothers_day(year):\n    may_days = [day for day in range(1, 32) if datetime.datetime(year, 5, day).weekday() == 6 and day <= 14]\n    return max(may_days) + 7\n\ndef get_fathers_day(year):\n    june_days = [day for day in range(1, 32) if datetime.datetime(year, 6, day).weekday() == 6 and day <= 21]\n    return max(june_days) + 14\n\ndef get_parent_gap(year):\n    mothers_day = get_mothers_day(year)\n    fathers_day = get_fathers_day(year)\n    parent_gap = (datetime.datetime(year, 6, fathers_day) - datetime.datetime(year, 5, mothers_day)).days // 7\n    if parent_gap == 5:\n        return \"5 weeks\"\n    else:\n        return \"6 weeks\"\n\ndef main():\n    year = int(input())\n    print(get_parent_gap(year))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Judging Troubles", "final_solution": "from collections import Counter\n\ndef main():\n    n = int(input())\n    domjudge_results = [input() for _ in range(n)]\n    kattis_results = [input() for _ in range(n)]\n    \n    domjudge_counter = Counter(domjudge_results)\n    kattis_counter = Counter(kattis_results)\n    \n    max_consistent = 0\n    for result in set(domjudge_results) & set(kattis_results):\n        max_consistent += min(domjudge_counter[result], kattis_counter[result])\n    print(min(max_consistent, n))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "from collections import Counter\n\ndef main():\n    n = int(input())\n    domjudge_results = [input() for _ in range(n)]\n    kattis_results = [input() for _ in range(n)]\n    \n    domjudge_counter = Counter(domjudge_results)\n    kattis_counter = Counter(kattis_results)\n    \n    common_results = set(domjudge_results) & set(kattis_results)\n    max_consistent = 0\n    for result in common_results:\n        max_consistent += min(domjudge_counter[result], kattis_counter[result])\n    \n    print(max_consistent)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Alien Numbers", "final_solution": "def main():\n    T = int(input())\n    for case in range(1, T + 1):\n        alien_number, source_language, target_language = input().split()\n        if not set(alien_number).issubset(set(source_language)):\n            print(f\"Case #{case}: Error: Invalid alien number\")\n            continue\n        source_to_decimal = {}\n        for i, digit in enumerate(source_language):\n            source_to_decimal[digit] = i\n        decimal = 0\n        for i, digit in enumerate(reversed(alien_number)):\n            decimal += source_to_decimal[digit] * (len(source_language) ** i)\n        target_to_decimal = {}\n        for i, digit in enumerate(target_language):\n            target_to_decimal[i] = digit\n        target_number = ''\n        while decimal > 0:\n            decimal, remainder = divmod(decimal, len(target_language))\n            target_number = target_to_decimal[remainder] + target_number\n        print(f\"Case #{case}: {target_number}\")\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    T = int(input())\n    for case in range(1, T + 1):\n        alien_number, source_language, target_language = input().split()\n        source_to_decimal = {}\n        for i, digit in enumerate(source_language):\n            source_to_decimal[digit] = i\n        decimal = 0\n        for digit in alien_number:\n            decimal = decimal * len(source_language) + source_to_decimal[digit]\n        target_to_decimal = {}\n        for i, digit in enumerate(target_language):\n            target_to_decimal[i] = digit\n        target_number = ''\n        while decimal > 0:\n            decimal, remainder = divmod(decimal, len(target_language))\n            target_number = target_to_decimal[remainder] + target_number\n        print(f\"Case #{case}: {target_number}\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Best Compression Ever", "final_solution": "import math\n\ndef main():\n    N, b = map(int, input().split())\n    if math.log2(N * 1000) <= b:\n        print(\"yes\")\n    else:\n        print(\"no\")\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import math\n\ndef main():\n    N, b = map(int, input().split())\n    if math.log2(N) <= b:\n        print(\"yes\")\n    else:\n        print(\"no\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "From A to B", "final_solution": "from collections import deque\n\ndef min_operations(a, b):\n    queue = deque([(a, 0)])\n    visited = set([a])\n    \n    while queue:\n        num, step = queue.popleft()\n        \n        if num == b:\n            return step\n        \n        if num - 1 not in visited and num - 1 >= 1:\n            queue.append((num - 1, step + 1))\n            visited.add(num - 1)\n        \n        if num % 2 == 0 and num // 2 not in visited and num // 2 >= 1:\n            queue.append((num // 2, step + 1))\n            visited.add(num // 2)\n        \n        if num + 1 not in visited:\n            queue.append((num + 1, step + 1))\n            visited.add(num + 1)\n\ndef main():\n    a, b = map(int, input().split())\n    print(min_operations(a, b))\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "from collections import deque\n\ndef min_operations(a, b):\n    queue = deque([(a, 0)])\n    visited = set([a])\n    \n    while queue:\n        num, step = queue.popleft()\n        \n        if num == b:\n            return step\n        \n        if num % 2 == 0 and num // 2 not in visited:\n            queue.append((num // 2, step + 1))\n            visited.add(num // 2)\n        \n        if num + 1 not in visited:\n            queue.append((num + 1, step + 1))\n            visited.add(num + 1)\n\ndef main():\n    a, b = map(int, input().split())\n    print(min_operations(a, b))\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Election", "final_solution": "def main():\n    n = int(input())\n    candidates = {}\n    for _ in range(n):\n        candidate = input()\n        party = input()\n        candidates[candidate] = party\n\n    m = int(input())\n    votes = {}\n    for _ in range(m):\n        candidate = input()\n        if candidate in candidates:\n            if candidate in votes:\n                votes[candidate] += 1\n            else:\n                votes[candidate] = 1\n\n    max_votes = max(votes.values(), default=0)\n    winners = [candidate for candidate, vote in votes.items() if vote == max_votes]\n\n    if len(winners) == 1:\n        print(candidates[winners[0]])\n    elif len(winners) > 1:\n        print(\"tie\")\n    else:\n        print(\"No winner\")\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    n = int(input())\n    candidates = {}\n    for _ in range(n):\n        candidate = input()\n        party = input()\n        candidates[candidate] = party\n\n    m = int(input())\n    votes = {}\n    for _ in range(m):\n        candidate = input()\n        if candidate in candidates:\n            if candidate in votes:\n                votes[candidate] += 1\n            else:\n                votes[candidate] = 1\n\n    max_votes = max(votes.values(), default=0)\n    winners = [candidate for candidate, vote in votes.items() if vote == max_votes]\n\n    if len(winners) == 1:\n        print(candidates[winners[0]])\n    elif len(winners) > 1:\n        print(\"tie\")\n    else:\n        print(\"No winner\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Beekeeper", "final_solution": "import sys\n\ndef count_double_vowels(word):\n    vowels = 'aeiouy'\n    count = 0\n    for i in range(len(word) - 1):\n        if word[i] in vowels and word[i] == word[i + 1]:\n            count += 1\n    return count\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        words = [input() for _ in range(n)]\n        max_count = 0\n        favorite_words = []\n        for word in words:\n            count = count_double_vowels(word)\n            if count > max_count:\n                max_count = count\n                favorite_words = [word]\n            elif count == max_count:\n                favorite_words.append(word)\n        print(favorite_words[0])\n\nif __name__ == '__main__':\n    main()\n", "initial_solution": "\ndef count_double_vowels(word):\n    vowels = 'aeiouy'\n    count = 0\n    for i in range(len(word) - 1):\n        if word[i] in vowels and word[i] == word[i + 1]:\n            count += 1\n    return count\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        words = [input() for _ in range(n)]\n        max_count = 0\n        favorite_word = ''\n        for word in words:\n            count = count_double_vowels(word)\n            if count > max_count:\n                max_count = count\n                favorite_word = word\n        print(favorite_word)\n\nif __name__ == '__main__':\n    main()\n"}
{"task_id": "Cross Country", "final_solution": "import sys\nimport heapq\n\ndef dijkstra(graph, start):\n    distances = [sys.maxsize] * len(graph)\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        \n        if current_distance > distances[current_node]:\n            continue\n        \n        for neighbor, weight in enumerate(graph[current_node]):\n            if weight > 0:  # Check if there is an edge between the nodes\n                distance = current_distance + weight\n                \n                if distance < distances[neighbor]:\n                    distances[neighbor] = distance\n                    heapq.heappush(pq, (distance, neighbor))\n    \n    return distances\n\ndef main():\n    N, S, T = map(int, input().split())\n    graph = [list(map(int, input().split())) for _ in range(N)]\n    \n    distances = dijkstra(graph, S)\n    if distances[T] == sys.maxsize:\n        print(-1)  # Print -1 if there is no path from S to T\n    else:\n        print(distances[T])\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import sys\nimport heapq\n\ndef dijkstra(graph, start):\n    distances = [sys.maxsize] * len(graph)\n    distances[start] = 0\n    pq = [(0, start)]\n    \n    while pq:\n        current_distance, current_node = heapq.heappop(pq)\n        \n        for neighbor, weight in enumerate(graph[current_node]):\n            distance = current_distance + weight\n            \n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(pq, (distance, neighbor))\n    \n    return distances\n\ndef main():\n    N, S, T = map(int, input().split())\n    graph = [list(map(int, input().split())) for _ in range(N)]\n    \n    distances = dijkstra(graph, S)\n    print(distances[T])\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Candle Box", "final_solution": "def main():\n    D = int(input())\n    R = int(input())\n    T = int(input())\n\n    # Calculate Rita's age\n    Rita_age = 4 + D\n\n    # Calculate Theo's age\n    Theo_age = Rita_age - D\n\n    # Calculate the correct number of candles in Rita's box\n    correct_candles = Rita_age\n\n    # Calculate the correct number of candles in Theo's box\n    correct_candles_theo = max(0, Theo_age - 3)\n\n    # Calculate the number of candles Rita needs to remove\n    remove_candles = R - correct_candles + (T - correct_candles_theo)\n\n    # Ensure remove_candles is not negative\n    remove_candles = max(0, remove_candles)\n\n    print(remove_candles)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "\ndef main():\n    D = int(input())\n    R = int(input())\n    T = int(input())\n\n    # Calculate the correct number of candles in Rita's box\n    correct_candles = (Rita_age := 4 + D) + Rita_age - 4\n\n    # Calculate the number of candles Rita needs to remove\n    remove_candles = R - correct_candles + T\n\n    print(remove_candles)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Prime Reduction", "final_solution": "import math\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef prime_factors(n):\n    factors = []\n    for i in range(2, int(math.sqrt(n)) + 1):\n        while n % i == 0:\n            factors.append(i)\n            n //= i\n    if n > 1:\n        factors.append(n)\n    return factors\n\ndef prime_reduction(n):\n    count = 0\n    while True:\n        count += 1\n        if is_prime(n):\n            return n, count\n        factors = prime_factors(n)\n        n = sum(factors)\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 4:\n            break\n        result, count = prime_reduction(n)\n        print(f\"{result} {count}\")\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "import math\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            return False\n    return True\n\ndef prime_reduction(n):\n    count = 0\n    while True:\n        if is_prime(n):\n            return n, count\n        factors = []\n        for i in range(2, int(math.sqrt(n)) + 1):\n            while n % i == 0:\n                factors.append(i)\n                n //= i\n        if n > 1:\n            factors.append(n)\n        n = sum(factors)\n        count += 1\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 4:\n            break\n        result, count = prime_reduction(n)\n        print(f\"{result} {count}\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Battle Simulation", "final_solution": "def main():\n    monster_moves = input()\n\n    mech_moves = ''\n    i = 0\n    while i < len(monster_moves):\n        if i < len(monster_moves) - 2:\n            if set(monster_moves[i:i+3]) == set('RBL'):\n                mech_moves += 'C'\n                i += 3\n            elif set(monster_moves[i:i+2]) == set('RB') or set(monster_moves[i:i+2]) == set('BR') or set(monster_moves[i:i+2]) == set('RL') or set(monster_moves[i:i+2]) == set('LR') or set(monster_moves[i:i+2]) == set('BL') or set(monster_moves[i:i+2]) == set('LB'):\n                mech_moves += 'C'\n                i += 2\n            else:\n                if monster_moves[i] == 'R':\n                    mech_moves += 'S'\n                elif monster_moves[i] == 'B':\n                    mech_moves += 'K'\n                elif monster_moves[i] == 'L':\n                    mech_moves += 'H'\n                i += 1\n        else:\n            if monster_moves[i] == 'R':\n                mech_moves += 'S'\n            elif monster_moves[i] == 'B':\n                mech_moves += 'K'\n            elif monster_moves[i] == 'L':\n                mech_moves += 'H'\n            i += 1\n\n    print(mech_moves)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    monster_moves = input()\n\n    mech_moves = ''\n    i = 0\n    while i < len(monster_moves):\n        if i < len(monster_moves) - 2 and (monster_moves[i] == 'R' and monster_moves[i+1] == 'B' and monster_moves[i+2] == 'L') or \\\n           (monster_moves[i] == 'R' and monster_moves[i+1] == 'L' and monster_moves[i+2] == 'B') or \\\n           (monster_moves[i] == 'B' and monster_moves[i+1] == 'R' and monster_moves[i+2] == 'L') or \\\n           (monster_moves[i] == 'B' and monster_moves[i+1] == 'L' and monster_moves[i+2] == 'R') or \\\n           (monster_moves[i] == 'L' and monster_moves[i+1] == 'R' and monster_moves[i+2] == 'B') or \\\n           (monster_moves[i] == 'L' and monster_moves[i+1] == 'B' and monster_moves[i+2] == 'R'):\n            mech_moves += 'C'\n            i += 3\n        else:\n            if monster_moves[i] == 'R':\n                mech_moves += 'S'\n            elif monster_moves[i] == 'B':\n                mech_moves += 'K'\n            elif monster_moves[i] == 'L':\n                mech_moves += 'H'\n            i += 1\n\n    print(mech_moves)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Which Base is it Anyway?", "final_solution": "def main():\n    P = int(input())\n    for K in range(1, P + 1):\n        data_set = input().split()\n        K = data_set[0]\n        num_str = data_set[1]\n        \n        # Convert to decimal\n        decimal = int(num_str)\n        \n        # Convert to octal\n        try:\n            octal = int(num_str, 8)\n        except ValueError:\n            octal = 0\n        \n        # Convert to hexadecimal\n        hexadecimal = int(num_str, 16)\n        \n        print(f\"{K} {octal} {decimal} {hexadecimal}\")\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    P = int(input())\n    for K in range(1, P + 1):\n        data_set = input().split()\n        K = data_set[0]\n        num_str = data_set[1]\n        \n        # Convert to decimal\n        decimal = int(num_str)\n        \n        # Convert to octal\n        try:\n            octal = int(num_str, 8)\n        except ValueError:\n            octal = 0\n        \n        # Convert to hexadecimal\n        hexadecimal = int(num_str, 16)\n        \n        print(f\"{K} {octal} {decimal} {hexadecimal}\")\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "99 Problems", "final_solution": "def main():\n    N = int(input())\n    if N % 100 == 0:\n        N -= 1\n    lower = N - (N % 100) + 99\n    upper = lower + 100\n    if upper - N <= N - lower:\n        print(upper)\n    else:\n        print(lower)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "def main():\n    N = int(input())\n    if N % 100 == 0:\n        N -= 1\n    lower = N - (N % 100) + 99\n    upper = lower + 100\n    if upper - N <= N - lower:\n        print(upper)\n    else:\n        print(lower)\n\nif __name__ == \"__main__\":\n    main()\n"}
{"task_id": "Awkward Party", "final_solution": "from collections import defaultdict\n\ndef main():\n    n = int(input())\n    languages = list(map(int, input().split()))\n    \n    language_indices = defaultdict(list)\n    for i, language in enumerate(languages):\n        language_indices[language].append(i)\n    \n    max_awkwardness = n\n    for indices in language_indices.values():\n        if len(indices) > 1:\n            min_diff = float('inf')\n            for i in range(len(indices) - 1):\n                min_diff = min(min_diff, indices[i + 1] - indices[i])\n            max_awkwardness = min(max_awkwardness, min_diff)\n    \n    print(max_awkwardness)\n\nif __name__ == \"__main__\":\n    main()\n", "initial_solution": "from collections import defaultdict\n\ndef main():\n    n = int(input())\n    languages = list(map(int, input().split()))\n    \n    language_indices = defaultdict(list)\n    for i, language in enumerate(languages):\n        language_indices[language].append(i)\n    \n    max_awkwardness = n\n    for indices in language_indices.values():\n        if len(indices) > 1:\n            min_diff = float('inf')\n            for i in range(len(indices) - 1):\n                min_diff = min(min_diff, indices[i + 1] - indices[i])\n            max_awkwardness = min(max_awkwardness, min_diff)\n    \n    print(max_awkwardness)\n\nif __name__ == \"__main__\":\n    main()\n"}
